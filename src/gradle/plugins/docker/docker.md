#### [Введение](#Введение-1)
#### [Основные концепции](#Основные-концепции-1)
#### [Примеры конфигурации](#Примеры-конфигурации-1)
#### [Ошибки и решения](#Ошибки-и-решения-1)
#### [Best Practices](#best-practices-1)

---

## Введение
Docker Plugin для Gradle — это мощный инструмент, который упрощает автоматизированное создание, управление и публикацию Docker-образов в различных окружениях. Он позволяет разработчикам интегрировать контейнеризацию прямо в процесс сборки проекта, избегая ручных действий при работе с Docker CLI. Использование Docker Plugin особенно важно для высоконагруженных систем, так как оно позволяет ускорить развертывание сервисов и минимизировать проблемы с зависимостями окружения.

## Основные концепции
- **Практическое определение:** Docker Plugin предназначен для автоматизации взаимодействия Gradle с Docker, что позволяет разработчикам управлять контейнерами и образами, не выходя за пределы конфигурации сборки.
- **Контекст из индустрии:** В крупных проектах, таких как Netflix и Spotify, контейнеризация является стандартом. Использование Docker Plugin позволяет упростить создание образов, их оптимизацию и распространение, обеспечивая предсказуемость развертывания.
- **Разъяснение терминов:**
   - *Layered Image* — метод упаковки Docker-образов, при котором неизменяемые слои переиспользуются для уменьшения размера и ускорения загрузки.
   - *Docker Daemon* — процесс, управляющий контейнерами и взаимодействующий с API Docker.
   - *Docker Registry* — централизованное хранилище образов, например, Docker Hub или Amazon ECR.
   - *Multi-stage build* — метод сборки, позволяющий создавать оптимизированные образы путём разделения сборочных и финальных слоёв.

## Примеры конфигурации

### Подключение плагина в `build.gradle.kts`
```kotlin
plugins {
    id("com.bmuschko.docker-remote-api") version "9.3.0"
}

docker {
    registryCredentials {
        username.set("my-user")
        password.set("my-password")
    }
}
```

### Создание Docker-образа с тегированием
```kotlin
tasks.register<com.bmuschko.gradle.docker.tasks.image.DockerBuildImage>("buildDockerImage") {
    inputDir.set(file("."))
    images.add("my-app:latest")
    images.add("my-app:\${project.version}")
}
```

### Публикация образа в Docker Registry
```kotlin
tasks.register<com.bmuschko.gradle.docker.tasks.image.DockerPushImage>("pushDockerImage") {
    imageName.set("my-app:latest")
}
```

### Запуск контейнера с переменными окружения и портами
```kotlin
tasks.register<com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer>("createContainer") {
    targetImageId.set("my-app:latest")
    envVars.put("SPRING_PROFILES_ACTIVE", "prod")
    portBindings.add("8080:8080")
}

tasks.register<com.bmuschko.gradle.docker.tasks.container.DockerStartContainer>("startContainer") {
    targetContainerId.set(createContainer.get().containerId)
}
```

## Ошибки и решения

| Ошибка | Причина | Решение |
|---|---|---|
| `Cannot connect to the Docker daemon` | Docker не запущен или нет доступа | Запустите `dockerd`, проверьте права доступа и настройки `DOCKER_HOST` |
| Ошибка аутентификации в Registry | Неверные учетные данные или недостаточные права | Проверьте `registryCredentials` и используйте `docker login` вручную для теста |
| Медленная сборка образов | Плохая кэшируемость слоев или большие зависимости | Оптимизируйте `Dockerfile`, используйте `multi-stage builds`, минимизируйте базовые образы |
| Контейнер сразу останавливается | Приложение завершает выполнение | Убедитесь, что процесс внутри контейнера остаётся активным, например, добавьте `ENTRYPOINT ["java", "-jar", "app.jar"]` |

## Best Practices
1. **Используйте `.dockerignore`**: Исключите ненужные файлы из сборки образа, чтобы уменьшить его размер и ускорить билд.
2. **Оптимизируйте порядок слоев в `Dockerfile`**: Сначала копируйте зависимости, затем исходный код, чтобы повысить кэшируемость.
3. **Автоматизируйте публикацию образов**: Интеграция с `docker push` в CI/CD (GitHub Actions, GitLab CI/CD, Jenkins).
4. **Минимизируйте размер образов**: Используйте `alpine`, `distroless` или `scratch` для минимального потребления ресурсов.
5. **Мониторинг и логирование**: Включите `Docker Healthcheck`, настроите `Prometheus` и `Grafana` для сбора метрик.
6. **Разделяйте окружения**: Используйте переменные среды и `docker-compose` для настройки разных конфигураций (development, staging, production).
7. **Избегайте запуска контейнеров под root**: Используйте `USER` в `Dockerfile`, чтобы минимизировать риски безопасности.
8. **Контролируйте версии зависимостей**: Фиксируйте версии базовых образов и пакетов, чтобы избежать неожиданных изменений в окружении.
9. **Используйте `multi-stage builds`**: Это позволяет уменьшить размер финального образа, сохраняя только необходимые артефакты.
10. **Настроите `ENTRYPOINT` и `CMD` правильно**: `ENTRYPOINT` задаёт процесс, который всегда выполняется, а `CMD` определяет параметры по умолчанию.

