#### [Введение](#Введение-1)
#### [Основные концепции](#Основные-концепции-1)
#### [Примеры кода на Kotlin](#Примеры-кода-на-kotlin-1)
#### [Ошибки и подводные камни](#Ошибки-и-подводные-камни-1)
#### [Сравнение с альтернативами](#Сравнение-с-альтернативами-1)
#### [Best practices и антипаттерны](#best-practices-и-антипаттерны-1)

---
# Основные коллекции Kotlin

## Введение
Коллекции в Kotlin — это мощный инструмент для работы с наборами данных. Они активно используются в продакшене для обработки данных, кэширования, работы с очередями и многого другого. Понимание их особенностей и оптимизация их использования критичны для производительности приложений.

---

## Основные концепции

### 1. **List (Список)**
   - **Определение**: Упорядоченная коллекция с возможностью доступа по индексу. Может быть изменяемой (`MutableList`) или неизменяемой (`List`).
   - **Практическая польза**: Используется для хранения последовательностей данных, например, результатов запросов к БД или элементов UI.
   - **Реальный пример**: В микросервисе для обработки заказов список используется для хранения товаров в корзине.

### 2. **Set (Множество)**
   - **Определение**: Коллекция уникальных элементов без порядка. Может быть изменяемой (`MutableSet`) или неизменяемой (`Set`).
   - **Практическая польза**: Используется для удаления дубликатов или проверки на существование элемента.
   - **Реальный пример**: В сервисе рекомендаций множество используется для хранения уникальных ID товаров, которые пользователь уже просмотрел.

### 3. **Map (Словарь)**
   - **Определение**: Коллекция пар "ключ-значение". Может быть изменяемой (`MutableMap`) или неизменяемой (`Map`).
   - **Практическая польза**: Используется для быстрого доступа к данным по ключу, например, кэширования или конфигураций.
   - **Реальный пример**: В сервисе аутентификации словарь используется для хранения токенов пользователей (ключ — ID пользователя, значение — токен).

---

## Примеры кода на Kotlin

### 1. **Оптимизация работы с List**
```kotlin
// Пример: Фильтрация и преобразование списка заказов
val orders: List<Order> = fetchOrdersFromDB()

// Используем `mapNotNull` для преобразования и фильтрации
val validOrderIds = orders
    .mapNotNull { order ->
        if (order.isValid()) order.id else null
    }

// Ленивая обработка с помощью `asSequence`
val heavyProcessingResult = orders
    .asSequence()
    .filter { it.isPriority() }
    .map { it.processHeavyOperation() }
    .toList()
```

### 2. **Использование Set для уникальных данных**
```kotlin
// Пример: Удаление дубликатов из списка просмотренных товаров
val viewedProductIds: List<Int> = fetchViewedProductIds()
val uniqueProductIds: Set<Int> = viewedProductIds.toSet()

// Быстрая проверка на существование элемента
if (uniqueProductIds.contains(productId)) {
    println("Товар уже просмотрен")
}
```

### 3. **Эффективное использование Map**
```kotlin
// Пример: Кэширование данных о пользователях
val userCache: MutableMap<Int, User> = mutableMapOf()

fun getUser(id: Int): User {
    return userCache.getOrPut(id) {
        fetchUserFromDB(id)
    }
}
```

---

## Ошибки и подводные камни

### 1. **Использование `toList()` на больших коллекциях**
- Проблема: Преобразование `Sequence` в `List` на больших данных может привести к утечкам памяти.
- Решение: Работайте с `Sequence` до последнего момента, если данные большие.

### 2. **Неправильный выбор коллекции**
- Проблема: Использование `List` вместо `Set` для проверки на уникальность приводит к медленным операциям.
- Решение: Всегда выбирайте коллекцию, исходя из задачи (например, `Set` для уникальности).

---

## Сравнение с альтернативами

| Коллекция | Плюсы | Минусы | Альтернатива |
|-----------|-------|--------|--------------|
| `List`    | Быстрый доступ по индексу, сохраняет порядок | Медленный поиск элемента | `Set` (если нужна уникальность) |
| `Set`     | Быстрая проверка на уникальность | Нет порядка | `List` (если порядок важен) |
| `Map`     | Быстрый доступ по ключу | Занимает больше памяти | `List` (если ключи — индексы) |

---

## Best practices и антипаттерны

### Best practices
1. **Используйте `Sequence` для ленивых операций**
    - Пример: `list.asSequence().filter { ... }.map { ... }.toList()`
    - Почему: Экономит память и ускоряет обработку больших данных.

2. **Выбирайте правильную коллекцию под задачу**
    - Пример: Для уникальных данных — `Set`, для пар "ключ-значение" — `Map`.
    - Почему: Улучшает производительность и читаемость кода.

3. **Используйте `mapNotNull` для фильтрации и преобразования**
    - Пример: `list.mapNotNull { if (it.isValid()) it.transform() else null }`
    - Почему: Упрощает код и избегает лишних операций.

### Антипаттерны
1. **Преобразование `Sequence` в `List` на ранних этапах**
    - Почему: Теряются преимущества ленивой обработки.
    - Пример: `sequence.toList().filter { ... }` (вместо `sequence.filter { ... }.toList()`).

2. **Использование `MutableList` без необходимости**
    - Почему: Усложняет поддержку и приводит к ошибкам.
    - Пример: Использование `MutableList` для конфигураций, которые не изменяются.
