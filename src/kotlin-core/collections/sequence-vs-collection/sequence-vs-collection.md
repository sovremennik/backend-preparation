#### [Введение](#Введение-1)
#### [Основные концепции](#Основные-концепции-1)
#### [Примеры кода на Kotlin](#Примеры-кода-на-kotlin-1)
#### [Ошибки и подводные камни](#Ошибки-и-подводные-камни-1)
#### [Сравнение Sequence и Collection](#Сравнение-sequence-и-collection-1)
#### [Best practices и антипаттерны](#best-practices-и-антипаттерны-1)

---
# Разница между Sequence и Collection в Kotlin

## Введение
В Kotlin `Sequence` и `Collection` — это два основных способа работы с наборами данных. Понимание их различий важно для написания эффективного кода, особенно при обработке больших объемов данных или выполнении цепочек операций. `Sequence` лениво вычисляет элементы, что может значительно улучшить производительность, в то время как `Collection` выполняет операции eagerly (сразу).

---

## Основные концепции

### 1. **Collection**
- **Eager evaluation**: Все операции выполняются сразу, и каждая операция возвращает новую коллекцию.
- **Пример из реального кейса**: Используется для работы с небольшими наборами данных, где важна простота и предсказуемость.

### 2. **Sequence**
- **Lazy evaluation**: Элементы вычисляются только тогда, когда они действительно нужны (например, при вызове терминальной операции).
- **Пример из реального кейса**: Используется для обработки больших данных или цепочек операций, где важно минимизировать использование памяти и улучшить производительность.

---

## Примеры кода на Kotlin

### 1. **Collection (eager evaluation)**
```kotlin
val numbers = listOf(1, 2, 3, 4, 5)

// Все операции выполняются сразу
val result = numbers
    .filter { println("Filtering $it"); it % 2 == 0 } // Промежуточная операция
    .map { println("Mapping $it"); it * 2 }          // Промежуточная операция
    .toList()                                        // Терминальная операция

// Вывод:
// Filtering 1
// Filtering 2
// Filtering 3
// Filtering 4
// Filtering 5
// Mapping 2
// Mapping 4
```

### 2. **Sequence (lazy evaluation)**
```kotlin
val numbers = listOf(1, 2, 3, 4, 5)

// Операции выполняются только при вызове терминальной операции
val result = numbers.asSequence()
    .filter { println("Filtering $it"); it % 2 == 0 } // Промежуточная операция
    .map { println("Mapping $it"); it * 2 }          // Промежуточная операция
    .toList()                                        // Терминальная операция

// Вывод:
// Filtering 1
// Filtering 2
// Mapping 2
// Filtering 3
// Filtering 4
// Mapping 4
// Filtering 5
```

---

## Ошибки и подводные камни

1. **Использование `Sequence` для небольших данных**:
    - Ошибка: Для небольших коллекций использование `Sequence` может быть избыточным и даже медленнее из-за накладных расходов на ленивые вычисления.
    - Решение: Используйте `Collection` для небольших данных.

2. **Игнорирование терминальных операций**:
    - Ошибка: Если забыть вызвать терминальную операцию (например, `toList()`), `Sequence` не выполнит вычисления.
    - Решение: Всегда завершайте цепочку операций терминальной операцией.

---

## Сравнение Sequence и Collection

| Характеристика          | Collection                          | Sequence                          |
|-------------------------|-------------------------------------|-----------------------------------|
| **Вычисление**          | Eager (сразу)                      | Lazy (по требованию)             |
| **Промежуточные операции** | Создают новую коллекцию           | Не выполняются до терминальной операции |
| **Память**              | Может использовать больше памяти   | Экономит память                  |
| **Производительность**  | Быстрее для небольших данных       | Эффективнее для больших данных или цепочек операций |
| **Использование**       | Простые операции с малыми данными  | Сложные цепочки операций или большие данные |

---

## Best practices и антипаттерны

### Best practices
1. **Используйте `Sequence` для больших данных**:
   ```kotlin
   val largeList = (1..1_000_000).toList()
   val result = largeList.asSequence()
       .filter { it % 2 == 0 }
       .map { it * 2 }
       .toList()
   ```

2. **Используйте `Collection` для простых операций**:
   ```kotlin
   val smallList = listOf(1, 2, 3, 4, 5)
   val result = smallList.filter { it % 2 == 0 }.map { it * 2 }
   ```

3. **Комбинируйте `Sequence` и `Collection`**:
   ```kotlin
   val result = largeList.asSequence()
       .filter { it % 2 == 0 }
       .take(10) // Лениво берет первые 10 элементов
       .toList() // Преобразует в коллекцию для дальнейших операций
   ```

### Антипаттерны
1. **Использование `Sequence` для простых операций**:
    - Вместо:
      ```kotlin
      val result = listOf(1, 2, 3).asSequence().map { it * 2 }.toList()
      ```
    - Используйте:
      ```kotlin
      val result = listOf(1, 2, 3).map { it * 2 }
      ```

2. **Игнорирование терминальных операций**:
    - Вместо:
      ```kotlin
      val sequence = listOf(1, 2, 3).asSequence().map { it * 2 } // Ничего не произойдет
      ```
    - Используйте:
      ```kotlin
      val result = listOf(1, 2, 3).asSequence().map { it * 2 }.toList()
      ```
