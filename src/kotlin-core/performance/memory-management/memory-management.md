#### [Введение](#Введение-1)
#### [Модель управления памятью в Kotlin](#Модель-управления-памятью-в-kotlin-1)
#### [Сборка мусора (Garbage Collection)](#Сборка-мусора-garbage-collection-1)
#### [Управление аллокациями и уменьшение нагрузки на GC](#Управление-аллокациями-и-уменьшение-нагрузки-на-gc-1)
#### [Мониторинг и профилирование потребления памяти](#Мониторинг-и-профилирование-потребления-памяти-1)
#### [Best practices](#best-practices-1)
#### [Антипаттерны](#Антипаттерны-1)

---
# Работа с памятью

## Введение

Эффективное управление памятью критично для стабильности и производительности приложений. В Kotlin, как и в JVM в целом, управление памятью автоматизировано, но понимание её устройства позволяет избегать утечек памяти и неоптимального потребления ресурсов. В этой теме разберём управление памятью в Kotlin, сборку мусора, аллокации и оптимальные стратегии работы с объектами.

## Модель управления памятью в Kotlin

Kotlin использует автоматическое управление памятью через JVM, которое включает:
- **Heap (Куча)** – область для хранения объектов, управляемая сборщиком мусора.
- **Stack (Стек)** – хранит локальные переменные и вызовы функций.
- **Метаспейс (Metaspace)** – управляет метаданными классов, заменяя PermGen.
- **Off-heap** – область, используемая при работе с `ByteBuffer`, `Unsafe`, JNI и NIO.

### Пример распределения объектов

```kotlin
fun main() {
    val localVar = 42 // Размещается в стеке
    val obj = SomeClass() // Создаётся в куче
}

class SomeClass {
    val data = ByteArray(1024) // Выделяет 1KB в куче
}
```

## Сборка мусора (Garbage Collection)

JVM использует **GC (Garbage Collector)** для управления памятью. Основные алгоритмы:
- **G1 (Garbage-First)** – балансирует производительность и паузы.
- **ZGC** – минимизирует паузы, подходит для низколатентных сервисов.
- **Shenandoah** – снижает задержки при больших нагрузках.

### Влияние GC на Kotlin-приложения

GC влияет на задержки, а его настройки могут улучшить производительность серверных приложений.

```shell
# Пример запуска с G1GC
java -XX:+UseG1GC -jar app.jar
```

## Управление аллокациями и уменьшение нагрузки на GC

Ненужные аллокации создают нагрузку на GC. Оптимизация включает:
- Использование **value types** (`inline class` в Kotlin 1.5+).
- Применение **пулов объектов** (`object pooling`), например, `ThreadLocal`.
- Использование `ByteBuffer` для работы с большими массивами байтов без нагрузки на GC.

### Оптимизированная работа с объектами

```kotlin
inline class UserId(val id: Long) // Экономит память, хранясь как long

object ConnectionPool {
    private val pool = ConcurrentLinkedQueue<Connection>()
    fun getConnection(): Connection = pool.poll() ?: createNewConnection()
}
```

## Мониторинг и профилирование потребления памяти

Для анализа памяти используют:
- **JVM инструменты**: `jvisualvm`, `jcmd`, `jmap`.
- **Профайлеры**: YourKit, JProfiler, async-profiler.
- **Prometheus + Grafana** для мониторинга метрик.

### Пример сбора метрик памяти в Kotlin-сервисе

```kotlin
fun setupMonitoring() {
    val memoryMXBean = ManagementFactory.getMemoryMXBean()
    println("Heap usage: ${memoryMXBean.heapMemoryUsage}")
}
```

## Best practices

- **Избегать ненужных аллокаций**, используя `inline class` и `ByteBuffer`.
- **Оптимизировать работу с GC**, настраивая его параметры.
- **Использовать слабые ссылки** для кэшей и пулов объектов.
- **Мониторить использование памяти** в продакшене, анализируя дампы heap.

## Антипаттерны

- **Неограниченный рост коллекций**, ведущий к утечкам памяти.
- **Использование больших объектов без пула**, создающее нагрузку на GC.

```kotlin
val cache = mutableMapOf<Int, BigObject>() // Потенциальная утечка памяти
```

Эффективное управление памятью снижает нагрузку на GC, улучшает latency и уменьшает потребление ресурсов.

