#### [Введение](#Введение-1)
#### [Основные концепции](#Основные-концепции-1)
#### [Примеры кода на Kotlin](#Примеры-кода-на-kotlin-1)
#### [Ошибки и подводные камни](#Ошибки-и-подводные-камни-1)
#### [Сравнение с альтернативами](#Сравнение-с-альтернативами-1)
#### [Best practices и антипаттерны](#best-practices-и-антипаттерны-1)
#### [Инструменты и интеграции](#Инструменты-и-интеграции-1)

---
# Пользовательские исключения

## Введение
Пользовательские исключения в Kotlin позволяют разработчикам создавать специализированные типы ошибок, которые лучше отражают специфику бизнес-логики приложения. Они используются для повышения читаемости кода, упрощения отладки и обработки ошибок в сложных системах, таких как микросервисы или распределенные приложения.

## Основные концепции

### Определение пользовательских исключений
Пользовательские исключения — это классы, которые наследуются от базового класса `Throwable` или его подклассов (например, `Exception` или `RuntimeException`). Они позволяют добавлять дополнительные поля, методы и логику для обработки специфических ошибок.

Пример использования:
- В микросервисе для обработки платежей можно создать исключение `PaymentFailedException`, которое содержит информацию о коде ошибки, сумме платежа и идентификаторе транзакции.

### Преимущества пользовательских исключений
- **Четкость**: Упрощают понимание, какая именно ошибка произошла.
- **Гибкость**: Позволяют добавлять дополнительные данные для обработки ошибок.
- **Модульность**: Упрощают повторное использование кода обработки ошибок.

## Примеры кода на Kotlin

### Создание пользовательского исключения
```kotlin
class PaymentFailedException(
    val errorCode: Int,
    val transactionId: String,
    message: String
) : Exception(message)
```

### Использование пользовательского исключения
```kotlin
fun processPayment(amount: Double, transactionId: String) {
    if (amount <= 0) {
        throw PaymentFailedException(400, transactionId, "Invalid payment amount")
    }
    // Логика обработки платежа
}

fun main() {
    try {
        processPayment(-100.0, "txn123")
    } catch (e: PaymentFailedException) {
        println("Payment failed: ${e.message}, code: ${e.errorCode}, transaction: ${e.transactionId}")
    }
}
```

### Обработка исключений в микросервисах
```kotlin
class PaymentService {
    fun handlePaymentRequest(request: PaymentRequest) {
        try {
            processPayment(request.amount, request.transactionId)
        } catch (e: PaymentFailedException) {
            // Логирование ошибки и отправка уведомления
            logError(e)
            notifyUser(e.transactionId, e.message)
        }
    }

    private fun logError(e: PaymentFailedException) {
        // Логирование в ELK или Prometheus
        println("Error: ${e.message}, code: ${e.errorCode}")
    }

    private fun notifyUser(transactionId: String, message: String) {
        // Отправка уведомления через Kafka или RabbitMQ
        println("Notifying user about transaction $transactionId: $message")
    }
}
```

## Ошибки и подводные камни

### Переусложнение иерархии исключений
Создание слишком глубокой иерархии исключений может усложнить код. Например, если у вас есть `PaymentFailedException`, `InvalidAmountException`, `NetworkException` и т.д., это может привести к путанице.

**Решение**: Используйте композицию вместо наследования. Например, добавьте поле `errorType` в `PaymentFailedException`.

### Игнорирование контекста исключений
Если исключение не содержит достаточного контекста (например, идентификатора транзакции или кода ошибки), это затрудняет отладку.

**Решение**: Всегда добавляйте в исключения поля, которые помогут понять причину ошибки.

## Сравнение с альтернативами

| Подход                     | Плюсы                                      | Минусы                                     |
|----------------------------|--------------------------------------------|--------------------------------------------|
| Пользовательские исключения | Четкость, гибкость, модульность            | Риск переусложнения иерархии               |
| Использование кодов ошибок  | Простота реализации                        | Низкая читаемость, отсутствие контекста    |
| Логирование ошибок          | Упрощает отладку                           | Не заменяет обработку исключений           |

## Best practices и антипаттерны

### Best practices

1. **Добавляйте контекст в исключения**
    - Всегда включайте в исключения поля, которые помогут понять причину ошибки (например, `transactionId`, `errorCode`).

2. **Используйте проверяемые исключения для бизнес-логики**
    - Если ошибка является частью бизнес-логики (например, недостаточно средств на счете), используйте проверяемые исключения.

3. **Логируйте исключения на уровне сервисов**
    - Логируйте исключения в месте, где они обрабатываются, чтобы упростить отладку.

### Антипаттерны

1. **Игнорирование исключений**
    - Пустой блок `catch` — это прямой путь к неожиданным сбоям в работе приложения.

   ```kotlin
   try {
       processPayment(amount, transactionId)
   } catch (e: Exception) {
       // Антипаттерн: игнорирование исключения
   }
   ```

2. **Создание слишком общей иерархии исключений**
    - Использование одного исключения для всех типов ошибок затрудняет отладку.

   ```kotlin
   class AppException(message: String) : Exception(message)
   ```

## Инструменты и интеграции

- **Логирование**: Используйте ELK (Elasticsearch, Logstash, Kibana) или Prometheus для сбора и анализа логов.
- **Уведомления**: Интегрируйте исключения с системами уведомлений, такими как Kafka или RabbitMQ, для отправки оповещений в реальном времени.
- **Мониторинг**: Настройте мониторинг исключений через Grafana или Datadog.