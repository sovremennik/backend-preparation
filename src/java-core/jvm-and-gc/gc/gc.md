#### [Основные принципы работы GC](#Основные-принципы-работы-gc-1)
#### [Жизненный цикл объекта и GC](#Жизненный-цикл-объекта-и-gc-1)
#### [Алгоритмы сборки мусора](#Алгоритмы-сборки-мусора-1)
#### [Практический пример работы GC](#Практический-пример-работы-gc-1)
#### [Советы по оптимизации работы GC](#Советы-по-оптимизации-работы-gc-1)

---
# Garbage Collection (GC)

Garbage Collection (GC) — это процесс управления памятью в Java, который автоматически освобождает память от объектов, на которые больше нет ссылок. GC помогает предотвращать утечки памяти и снижает необходимость ручного управления памятью, как в C++.

## Основные принципы работы GC

1. **Поиск неиспользуемых объектов:**
    - GC ищет объекты, которые больше недоступны через цепочку ссылок.
    - Если объект не может быть достигнут из корневых ссылок (GC Roots), он считается мусором.

2. **Удаление объектов:**
    - После обнаружения мусора память, занимаемая этими объектами, освобождается.

3. **Оптимизация работы:**
    - Современные реализации GC используют алгоритмы, минимизирующие паузы в работе приложения (например, параллельный или конвейерный GC).

---

## Жизненный цикл объекта и GC

### 1. Создание объекта:
Объект создаётся в куче (Heap):

```
+-------------------------------+
|           HEAP               |
|  +-------------------------+  |
|  |  Object (reachable)     |  |
|  +-------------------------+  |
+-------------------------------+
```

### 2. Потеря ссылок:
Если на объект больше нет ссылок, он становится кандидатом для GC:

```
+-------------------------------+
|           HEAP               |
|  +-------------------------+  |
|  |  Object (unreachable)   |  |
|  +-------------------------+  |
+-------------------------------+
```

### 3. Сборка мусора:
GC освобождает память, занятую недостижимым объектом:

```
+-------------------------------+
|           HEAP               |
|                               |
|       (Free memory)           |
+-------------------------------+
```

---

## Алгоритмы сборки мусора

### 1. **Mark-and-Sweep (Пометка и очистка):**
- **Этап Mark:** GC обходит объекты, начиная с GC Roots, и отмечает все достижимые объекты.
- **Этап Sweep:** Все неотмеченные объекты удаляются, освобождая память.

#### Пример:
```
До:
+---+---+---+---+---+
| X | O | O | X | O |
+---+---+---+---+---+
   X = Unreachable
   O = Reachable

После:
+---+---+---+---+---+
|   | O | O |   | O |
+---+---+---+---+---+
```

### 2. **Generational GC:**
- Куча делится на "молодое" и "старое" поколения:
    - **Young Generation:** Для новых объектов. Часто собирается.
    - **Old Generation:** Для долгоживущих объектов. Реже подвергается сборке.

#### Пример распределения:
```
+-------------------+
|    Young Gen      |
| +---+---+---+---+ |
| | O | O |   |   | |
| +---+---+---+---+ |
|                   |
|    Old Gen        |
| +-----------+     |
| |     O     |     |
| +-----------+     |
+-------------------+
```

### 3. **Concurrent Mark-Sweep (CMS):**
- Работает параллельно с приложением, минимизируя паузы.

### 4. **G1 Garbage Collector:**
- Делит кучу на регионы. Убирает регионы с наибольшим количеством мусора.

---

## Практический пример работы GC

```java
public class GarbageCollectionDemo {
    public static void main(String[] args) {
        Object obj1 = new Object();
        Object obj2 = new Object();

        obj1 = null; // Объект доступен для GC
        System.gc(); // Принудительный вызов GC

        System.out.println("GC вызван. Проверяйте логи.");
    }
}
```

#### Возможный лог:
```
[GC (System.gc()) 1024K->512K(4096K), 0.0056320 secs]
[Full GC (System.gc()) 512K->0K(4096K), 0.0104830 secs]
```

---

## Советы по оптимизации работы GC

1. **Избегайте утечек памяти:** Убедитесь, что ненужные объекты становятся недостижимыми.
2. **Используйте профилирование:** Анализируйте использование памяти и поведение GC с помощью инструментов (например, VisualVM, JConsole).
3. **Настройка JVM:** Используйте параметры JVM для выбора подходящего GC (например, `-XX:+UseG1GC`).
