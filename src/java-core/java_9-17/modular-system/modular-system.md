#### [Основные цели модульной системы](#Основные-цели-модульной-системы-1)
#### [Основные понятия модульной системы](#Основные-понятия-модульной-системы-1)
#### [Файл `module-info.java`](#Файл-module-infojava-1)
#### [Стандартные модули Java](#Стандартные-модули-java-1)
#### [Работа с модулями в реальном проекте](#Работа-с-модулями-в-реальном-проекте-1)
#### [Работа с модулями в реальном проекте](#Работа-с-модулями-в-реальном-проекте-1)
#### [Расширенные возможности](#Расширенные-возможности-1)
#### [Преимущества модульной системы](#Преимущества-модульной-системы-1)
#### [Практический пример использования](#Практический-пример-использования-1)
#### [Заключение](#Заключение-1)

---
# Модульная система Java (Project Jigsaw)

Модульная система Java, представленная в Java 9, является важным усовершенствованием платформы. Она вводит концепцию модулей, которая позволяет организовать код, улучшить управляемость больших приложений и повысить безопасность. Этот механизм получил название **Project Jigsaw**.

---

## Основные цели модульной системы

1. **Инкапсуляция**: Модули позволяют скрыть внутреннюю реализацию, предоставляя доступ только к явно экспортированным API.
2. **Управление зависимостями**: Возможность явно указывать зависимости между модулями.
3. **Оптимизация**: Уменьшение размера Java Runtime Environment (JRE) за счет использования только необходимых модулей.
4. **Безопасность**: Ограничение доступа к внутренним API модулей.
5. **Улучшение читаемости**: Явное указание того, какие части кода доступны и используются другими модулями.

---

## Основные понятия модульной системы

1. **Модуль** — это набор пакетов и ресурсов с явным описанием границ. Каждый модуль имеет файл `module-info.java`, который определяет его API и зависимости.
2. **Экспортируемый пакет** — пакет, который явно доступен другим модулям через директиву `exports`.
3. **Требуемый модуль** — модуль, который необходим для работы текущего модуля и указывается через директиву `requires`.
4. **Unnamed Module** — модуль, который включает код без явного описания в `module-info.java`.

---

## Файл `module-info.java`

Файл `module-info.java` расположен в корневом каталоге модуля и описывает:

- Какие пакеты экспортируются.
- От каких модулей зависит текущий модуль.
- Специальные требования (например, к открытию модулей для рефлексии).

### Пример:

```java
module com.example.myapp {
    requires java.sql; // Зависимость от стандартного модуля
    requires com.external.library; // Зависимость от стороннего модуля

    exports com.example.myapp.api; // Экспорт пакета API
}
```

---

## Стандартные модули Java

Модульная система предоставляет предопределенные модули, такие как:

- `java.base` — базовый модуль, автоматически доступный всем модулям.
- `java.sql` — работа с базами данных.
- `java.xml` — парсинг XML.
- `java.desktop` — графический интерфейс.

### Пример зависимостей:

```java
module com.example.database {
    requires java.sql;
    requires java.logging;
}
```

---

## Работа с модулями в реальном проекте

### 1. **Создание модуля**

1. В корневом каталоге создайте папку модуля, например `com.example.myapp`.
2. В папке создайте `module-info.java`.
3. Организуйте код, разделив пакеты по функциональности.

Пример структуры:

```
com.example.myapp/
  |-- module-info.java
  |-- com/example/myapp/
       |-- Main.java
       |-- utils/
           |-- StringUtils.java
```

### 2. **Компиляция модулей**

Используйте `javac` для компиляции модулей с указанием корня модульной системы:

```bash
javac -d out --module-source-path src $(find src -name "*.java")
```

### 3. **Запуск приложения**

Для выполнения модуля укажите корень модулей и имя основного класса:

```bash
java --module-path out -m com.example.myapp/com.example.myapp.Main
```

---

## Расширенные возможности

### Открытие модулей

Если модуль должен быть доступен для рефлексии (например, для работы с фреймворками), используйте директиву `opens`:

```java
module com.example.myapp {
    opens com.example.myapp.internal to framework.module;
}
```

### Транзитивные зависимости

Если модуль `A` зависит от модуля `B` и хочет автоматически предоставить модуль `B` модулям, которые зависят от `A`, используется ключевое слово `requires transitive`:

```java
module A {
    requires transitive B;
}
```

### Использование сервисов

Модульная система поддерживает концепцию сервисов для реализации паттерна "инверсия управления":

- **Определение сервиса:**

```java
module com.example.service {
    provides com.example.MyService with com.example.impl.MyServiceImpl;
}
```

- **Использование сервиса:**

```java
module com.example.consumer {
    requires com.example.service;

    uses com.example.MyService;
}
```

---

## Преимущества модульной системы

1. Улучшение читаемости кода за счет явного указания зависимостей.
2. Возможность создания легковесных версий JRE, содержащих только нужные модули (через `jlink`).
3. Уменьшение риска конфликтов между библиотеками.
4. Улучшенная безопасность за счет контроля доступа к API.

---

## Практический пример использования

### Модульное веб-приложение

1. **Модуль `web`:** отвечает за обработку HTTP-запросов.

```java
module com.example.web {
    requires com.example.service;
    exports com.example.web.controllers;
}
```

2. **Модуль `service`:** бизнес-логика приложения.

```java
module com.example.service {
    requires com.example.repository;
    exports com.example.service;
}
```

3. **Модуль `repository`:** работа с базой данных.

```java
module com.example.repository {
    requires java.sql;
    exports com.example.repository;
}
```
---

## Заключение
Модульная система — это мощный инструмент для управления сложными приложениями, который значительно улучшает структурированность, поддержку и безопасность кода. Ее использование особенно полезно в крупных проектах, где четкое разделение ответственности имеет решающее значение.
