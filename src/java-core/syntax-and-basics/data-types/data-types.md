#### [Примитивные типы данных](#Примитивные-типы-данных-1)
#### [Ссылочные типы данных](#Ссылочные-типы-данных-1)
#### [Примитивы и объекты](#Примитивы-и-объекты-1)
#### [String и пул строк](#string-и-пул-строк-1)
#### [Массивы](#Массивы-1)
#### [Обобщённые типы (Generics)](#Обобщённые-типы-generics-1)
#### [Тип var (с Java 10)](#Тип-var-с-java-10-1)
#### [Работа сборщика мусора (GC) с объектами](#Работа-сборщика-мусора-gc-с-объектами-1)

---

#  Типы данных

## Примитивные типы данных

Java предоставляет восемь примитивных типов данных, которые делятся на четыре группы:

1. **Целочисленные типы** (`byte`, `short`, `int`, `long`)
2. **Числа с плавающей точкой** (`float`, `double`)
3. **Символьный тип** (`char`)
4. **Логический тип** (`boolean`)

### Целочисленные типы (byte, short, int, long)

В Java предусмотрено четыре типа данных для представления целых чисел. Они различаются диапазоном значений и объемом занимаемой памяти.

| Тип    | Размер (бит) | Диапазон значений                | Пример использования |
|--------|--------------|-----------------------------------|-----------------------|
| `byte` | 8            | -128 до 127                      | Для компактного хранения данных |
| `short`| 16           | -32,768 до 32,767                | Используется редко, когда требуется немного больше диапазона, чем у `byte` |
| `int`  | 32           | -2,147,483,648 до 2,147,483,647  | Основной тип для целых чисел |
| `long` | 64           | -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807 | Для больших чисел |

#### Особенности

- **`byte`**: Используется для экономии памяти в больших массивах или потоках данных.
- **`short`**: Применяется редко из-за ограниченного диапазона, но занимает меньше памяти, чем `int`.
- **`int`**: Наиболее часто используемый тип для работы с целыми числами.
- **`long`**: Предназначен для случаев, когда требуется работать с очень большими числами.

#### Примеры кода

```java
public class IntegerTypes {
    public static void main(String[] args) {
        byte smallNumber = 100;
        short mediumNumber = 32000;
        int standardNumber = 1_000_000;
        long largeNumber = 10_000_000_000L; // Суффикс 'L' указывает, что это тип long

        System.out.println("byte: " + smallNumber);
        System.out.println("short: " + mediumNumber);
        System.out.println("int: " + standardNumber);
        System.out.println("long: " + largeNumber);
    }
}
```

#### Переполнение (Overflow)

> **Важно:** Java не предупреждает о переполнении значений.

Переполнение происходит, когда значение выходит за пределы диапазона типа. Например:

```java
public class OverflowExample {
    public static void main(String[] args) {
        byte maxByte = 127;
        maxByte += 1; // Переполнение
        System.out.println(maxByte); // Output: -128
    }
}
```

### Числа с плавающей точкой (float, double)

Java предоставляет два типа данных для представления чисел с плавающей точкой: `float` и `double`. Эти типы различаются точностью и объемом памяти.

| Тип     | Размер (бит) | Диапазон значений                     | Пример использования              |
|---------|--------------|----------------------------------------|------------------------------------|
| `float` | 32           | Примерно ±3.40282347E+38F (7 цифр)    | Для экономии памяти в больших массивах чисел с плавающей точкой |
| `double`| 64           | Примерно ±1.79769313486231570E+308 (15 цифр) | Основной тип для вещественных чисел |

#### Особенности

- **`float`**: Используется, когда требуется сохранить память. Число должно заканчиваться суффиксом `F` или `f` (например, `3.14F`).
- **`double`**: Основной тип данных для работы с числами с плавающей точкой. Имеет более высокую точность и не требует суффиксов, но можно использовать `D` или `d` для обозначения.

#### Примеры кода

```java
public class FloatingPointTypes {
    public static void main(String[] args) {
        float piApproximation = 3.14F;
        double precisePi = 3.141592653589793;

        System.out.println("float: " + piApproximation);
        System.out.println("double: " + precisePi);
    }
}
```

#### Особенности работы с числами с плавающей точкой

- **Неточная арифметика**: Операции с числами с плавающей точкой могут приводить к ошибкам округления.
  ```java
  public class FloatingPointError {
      public static void main(String[] args) {
          double a = 0.1;
          double b = 0.2;
          System.out.println(a + b); // Output: 0.30000000000000004
      }
  }
  ```

- **Специальные значения**: Типы `float` и `double` поддерживают специальные значения:
    - `+Infinity` и `-Infinity` (положительная и отрицательная бесконечность).
    - `NaN` (Not a Number), указывает на результат некорректных вычислений, например деления нуля на ноль.

  ```java
  public class SpecialValues {
      public static void main(String[] args) {
          System.out.println(1.0 / 0); // Output: Infinity
          System.out.println(-1.0 / 0); // Output: -Infinity
          System.out.println(0.0 / 0.0); // Output: NaN
      }
  }
  ```

#### BigDecimal для точных вычислений

> **Рекомендация:** Для финансовых и точных вычислений используйте `BigDecimal`.

```java
import java.math.BigDecimal;

public class BigDecimalExample {
    public static void main(String[] args) {
        BigDecimal value1 = new BigDecimal("0.1");
        BigDecimal value2 = new BigDecimal("0.2");
        BigDecimal sum = value1.add(value2);

        System.out.println("BigDecimal сумма: " + sum); // Output: 0.3
    }
}
```

### Символьный тип (`char`)

Тип `char` предназначен для хранения одиночного символа в формате Unicode и занимает 16 бит.

| Тип   | Размер (бит) | Диапазон значений | Значение по умолчанию |
|-------|--------------|------------------|----------------------|
| `char` | 16           | 0 до 65,535     | `\u0000` (null)      |

#### **Unicode и символы:**

Java использует стандарт **Unicode**, что позволяет хранить символы большинства языков.

```java
char letterA = 'A';
char unicodeChar = '\u0041';  // Unicode для 'A'
char numberChar = 65;         // Десятичный код символа 'A'

System.out.println(letterA);    // A
System.out.println(unicodeChar); // A
System.out.println(numberChar);  // A
```

> **Важно:** Символы обозначаются одинарными кавычками `' '`, строки — двойными кавычками `" "`.

#### **Работа с символами:**

```java
char symbol = 'Ж';
System.out.println((int) symbol);  // 1046 (Unicode)
```

> **Примечание:** Приведение `char` к `int` возвращает Unicode-код символа.

#### **Специальные символы:**

| Символ | Описание            |
|--------|---------------------|
| `\n`   | Новая строка        |
| `\t`   | Табуляция           |
| `\'`   | Одинарная кавычка   |
| `\"`   | Двойная кавычка     |
| `\\`   | Обратная косая черта |

```java
System.out.println("Первая строка\nВторая строка");
```

**Результат:**

```
Первая строка
Вторая строка
```

### Арифметические операции

#### Основные операции

Операции над числами включают:

- Сложение (`+`): Складывает два числа.
- Вычитание (`-`): Вычитает одно число из другого.
- Умножение (`*`): Умножает два числа.
- Деление (`/`): Делит одно число на другое.
- Остаток от деления (`%`): Возвращает остаток от деления одного числа на другое.

#### Приоритет операций

Операции выполняются в следующем порядке при отсутствии скобок:

1. Унарные операции (`+`, `-`)
2. Умножение, деление и остаток от деления (`*`, `/`, `%`)
3. Сложение и вычитание (`+`, `-`)

### Логические операции

#### Операции сравнения для примитивных типов данных

В Java операции сравнения применимы к примитивным типам данных (числовые типы, символы и логический тип). Эти операции возвращают логическое значение `true` или `false` в зависимости от результата сравнения.

1. **Равно (`==`)**
    - Проверяет, равны ли два значения.
    - Применяется ко всем примитивным типам.
    - **Пример:**
      ```java
      int a = 5;
      int b = 5;
      System.out.println(a == b);  // true
      ```

2. **Не равно (`!=`)**
    - Проверяет, не равны ли два значения.
    - **Пример:**
      ```java
      double x = 3.14;
      double y = 2.71;
      System.out.println(x != y);  // true
      ```

3. **Больше (`>`)**
    - Проверяет, больше ли одно значение другого.
    - **Пример:**
      ```java
      int age = 20;
      System.out.println(age > 18);  // true
      ```

4. **Меньше (`<`)**
    - Проверяет, меньше ли одно значение другого.
    - **Пример:**
      ```java
      int score = 75;
      System.out.println(score < 100);  // true
      ```

5. **Больше или равно (`>=`)**
    - Проверяет, больше или равно ли одно значение другому.
    - **Пример:**
      ```java
      int level = 10;
      System.out.println(level >= 10);  // true
      ```

6. **Меньше или равно (`<=`)**
    - Проверяет, меньше или равно ли одно значение другому.
    - **Пример:**
      ```java
      int speed = 60;
      System.out.println(speed <= 80);  // true
      ```

7. **Логическое НЕ (`!`)**
    - Инвертирует логическое значение. Если выражение истинно, результат будет ложным, и наоборот.
    - **Пример:**
      ```java
      boolean isActive = true;
      System.out.println(!isActive);  // false
      ```

#### Особенности применения
- Операции сравнения не работают с типом `boolean`, за исключением `==` и `!=`.
- Для строк и объектов следует использовать метод `.equals()`, а не `==`, поскольку `==` сравнивает ссылки, а не содержимое.

#### Заключение
Операции сравнения являются важной частью логических выражений и управления потоком выполнения программ. Они позволяют реализовывать ветвления и логические проверки в коде.

### Побитовые операции

Побитовые операции позволяют выполнять манипуляции на уровне отдельных битов целочисленных типов данных. В языке Java такие операции применяются к типам `byte`, `short`, `int`, `long`.

#### Таблица булевых функций для побитовых операций

| A | B | AND (A ∧ B) | OR (A ∨ B) | XOR (A ⊕ B) | NOT (¬A) |
|---|---|-----------------|---------------|-----------------|------------|
| 0 | 0 | 0               | 0             | 0               | 1          |
| 0 | 1 | 0               | 1             | 1               | 1          |
| 1 | 0 | 0               | 1             | 1               | 0          |
| 1 | 1 | 1               | 1             | 0               | 0          |

#### Описание операций

- **AND (∧):** Возвращает 1, если оба бита равны 1.
- **OR (∨):** Возвращает 1, если хотя бы один бит равен 1.
- **XOR (⊕):** Возвращает 1, если только один бит равен 1.
- **NOT (¬):** Инвертирует биты операнда.

#### Примеры кода

```java
int a = 5;  // 0101 в двоичном формате
int b = 3;  // 0011 в двоичном формате

int andResult = a & b;  // 0101 & 0011 = 0001 (1 в десятичном)
int orResult = a | b;   // 0101 | 0011 = 0111 (7 в десятичном)
int xorResult = a ^ b;  // 0101 ^ 0011 = 0110 (6 в десятичном)
int notResult = ~a;     // ~0101 = 1010 (в зависимости от разрядности числа)

System.out.println("AND: " + andResult);
System.out.println("OR: " + orResult);
System.out.println("XOR: " + xorResult);
System.out.println("NOT: " + notResult);
```

> **Примечание:** Побитовые операции часто используются для работы с флагами, настройками, масками битов и при оптимизации вычислений.


## Ссылочные типы данных

Ссылочные типы данных в Java — это типы данных, которые хранят ссылки на объекты в памяти. В отличие от примитивных типов, которые хранят реальные значения, ссылочные типы содержат указатели на данные, расположенные в куче (heap). Эти типы данных включают классы, интерфейсы, массивы, перечисления, аннотации и обобщения.

### Классы (class)

Класс в Java является шаблоном для создания объектов. Классы описывают поля (данные) и методы (поведение) объектов, создаваемых на основе этого класса. Каждый объект, созданный на основе класса, является экземпляром этого класса и имеет свою собственную копию данных.

Пример:
```java
public class Person {
    String name;
    int age;

    // Конструктор
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Метод
    public void greet() {
        System.out.println("Hello, my name is " + name + " and I am " + age + " years old.");
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person("Alice", 30);
        person.greet();  // Output: Hello, my name is Alice and I am 30 years old.
    }
}
```

### Интерфейсы (interface)

Интерфейс в Java — это абстрактный тип данных, который определяет контракт (набор методов), который должен быть реализован классами, использующими этот интерфейс. Интерфейсы позволяют создать полиморфизм, где разные классы могут реализовывать одинаковые методы, но с разной логикой.

Пример интерфейса:
```java
public interface Animal {
    void sound();
}

public class Dog implements Animal {
    @Override
    public void sound() {
        System.out.println("Woof!");
    }
}

public class Cat implements Animal {
    @Override
    public void sound() {
        System.out.println("Meow!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat();
        
        dog.sound();  // Output: Woof!
        cat.sound();  // Output: Meow!
    }
}
```

### Массивы

Массивы — это структуры данных, которые позволяют хранить несколько значений одного типа в одном объекте. В отличие от примитивных типов, массивы в Java являются ссылочными типами, что означает, что они ссылаются на область памяти, где хранятся их элементы.

Пример создания массива:
```java
int[] numbers = new int[5];  // Массив из 5 элементов
numbers[0] = 10;
numbers[1] = 20;
numbers[2] = 30;
numbers[3] = 40;
numbers[4] = 50;

System.out.println(numbers[0]);  // Output: 10
```

Инициализация массива значениями:
```java
String[] fruits = {"Apple", "Banana", "Cherry"};
System.out.println(fruits[1]);  // Output: Banana
```

### Перечисления (enum)

Перечисления (enum) в Java представляют собой тип данных, который позволяет задать набор фиксированных значений. Это удобный способ для работы с ограниченными наборами данных, такими как дни недели или состояния.

Пример перечисления:
```java
public enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

public class Main {
    public static void main(String[] args) {
        Day today = Day.MONDAY;
        System.out.println(today);  // Output: MONDAY
    }
}
```

### Аннотации (@interface)

Аннотации в Java — это метаданные, которые добавляют информацию о коде, но не изменяют его поведение. Аннотации широко используются в библиотеках и фреймворках для генерации дополнительного кода на основе метаданных.

Пример аннотации:
```java
public @interface Author {
    String name();
    String date();
}

@Author(name = "John Doe", date = "01/01/2025")
public class MyClass {
    // Класс с аннотацией
}
```

### Обобщения (Generics)

Обобщения (Generics) позволяют создавать универсальные классы, интерфейсы и методы, которые могут работать с любыми типами данных, обеспечивая безопасность типов и повторное использование кода. Они позволяют задавать типы данных в качестве параметров, улучшая читаемость и поддержку кода.

Пример использования обобщений:
```java
public class Box<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}

public class Main {
    public static void main(String[] args) {
        Box<Integer> integerBox = new Box<>();
        integerBox.setValue(100);
        System.out.println(integerBox.getValue());  // Output: 100

        Box<String> stringBox = new Box<>();
        stringBox.setValue("Hello, Generics!");
        System.out.println(stringBox.getValue());  // Output: Hello, Generics!
    }
}
```

## Примитивы и объекты

### Приведение типов

Приведение типов (type casting) в Java позволяет преобразовывать значения из одного типа данных в другой. Это необходимо для корректной работы с различными типами данных и оптимизации использования памяти.

#### Виды приведения типов

1. **Неявное (автоматическое) приведение типов (Widening Casting):**
   - Происходит автоматически, если преобразование безопасно и не приводит к потере данных.
   - Пример: преобразование из меньшего типа в больший (например, `int` → `long`).

   ```java
   int num = 100;
   long bigNum = num;  // Автоматическое приведение int к long
   double decimal = num;  // int к double
   ```

2. **Явное приведение типов (Narrowing Casting):**
   - Требует явного указания, поскольку может привести к потере данных.
   - Пример: преобразование из большего типа в меньший (например, `double` → `int`).

   ```java
   double price = 9.99;
   int roundedPrice = (int) price;  // Явное приведение, результат: 9
   
   long bigValue = 10000000000L;
   int smallValue = (int) bigValue;  // Потеря данных
   ```

#### Приведение между примитивными типами

- **byte → short → int → long → float → double** *(неявное)*
- **double → float → long → int → short → byte** *(явное)*

##### Примеры:

```java
short s = 100;
int i = s;  // Неявное приведение

double d = 123.456;
int n = (int) d;  // Явное приведение, результат: 123
```

#### Особенности приведения типов

- При **неявном** приведении данные не теряются.
- При **явном** приведении возможно:
   - Потеря точности (при преобразовании `double` в `int`).
   - Переполнение диапазона (при преобразовании больших значений `long` в `int`).

#### Приведение типов для операций

Иногда Java автоматически выполняет приведение типов в арифметических операциях:

```java
int a = 5;
double b = 6.5;
double result = a + b;  // a автоматически приводится к double
```

#### Приведение ссылочных типов (Upcasting и Downcasting)

- **Upcasting** — приведение от подкласса к суперклассу (безопасно и не требует явного указания).
- **Downcasting** — приведение от суперкласса к подклассу (требует явного указания и проверки).

```java
class Animal {}
class Dog extends Animal {}

Animal animal = new Dog();  // Upcasting
Dog dog = (Dog) animal;     // Downcasting
```

**Важно:** Неправильный Downcasting вызывает `ClassCastException`.

```java
Animal animal = new Animal();
Dog dog = (Dog) animal;  // Ошибка во время выполнения
```

### Автоупаковка (Autoboxing) и автораспаковка (Unboxing)

Java предоставляет удобные механизмы автоматического преобразования между примитивными типами данных и их объектными оболочками.

#### Определения

- **Автоупаковка (Autoboxing):** автоматическое преобразование примитивного типа данных в соответствующий объект-оболочку.
- **Автораспаковка (Unboxing):** автоматическое преобразование объекта-оболочки обратно в примитивный тип.

#### Примитивные типы и их оболочки
Классы-обёртки (Wrapper Classes) в Java обеспечивают объектную оболочку для примитивных типов данных. Это необходимо, когда требуется использовать примитивы в контексте объектов, например, в коллекциях или обобщениях. Каждый примитивный тип имеет соответствующий класс-обёртку в пакете `java.lang`:


| Примитивный тип | Класс-оболочка |
|-----------------|----------------|
| `byte`          | `Byte`         |
| `short`         | `Short`        |
| `int`           | `Integer`      |
| `long`          | `Long`         |
| `float`         | `Float`        |
| `double`        | `Double`       |
| `char`          | `Character`    |
| `boolean`       | `Boolean`      |

**Ключевые особенности классов-обёрток:**

1. **Неизменяемость (Immutability):** Все классы-обёртки являются неизменяемыми, что гарантирует безопасность данных.
2. **Методы для преобразования:** Классы-обёртки предоставляют методы для преобразования строк в числа (`parseInt`, `parseDouble`) и обратно (`toString`).
3. **Кэширование значений:** Java кэширует значения для `Integer`, `Short`, `Byte`, `Character` и `Boolean` в определённых диапазонах для оптимизации памяти.


#### Что происходит под капотом

- **Где хранятся объекты:**
   - Примитивные типы данных хранятся в стеке (Stack), что обеспечивает быстрый доступ и экономию памяти.
   - Объекты-оболочки создаются в куче (Heap), что требует больше памяти и увеличивает нагрузку на сборщик мусора.

- **Как работает автоупаковка:**
   - При автоупаковке используется вызов статического метода `valueOf()` соответствующего класса-оболочки. Например, `Integer.valueOf(primitiveInt)`.
   - Для часто используемых значений существует пул объектов (`IntegerCache`) для чисел от -128 до 127, что снижает нагрузку на память.

- **Как работает автораспаковка:**
   - В процессе автораспаковки вызывается метод экземпляра, например, `intValue()` для `Integer`, чтобы получить примитивное значение.

#### Методы классов-оболочек

Каждый класс-оболочка предоставляет полезные методы для работы с данными:

- **`parseXxx(String s)`** — преобразует строку в примитив:
  ```java
  int number = Integer.parseInt("123");
  ```

- **`valueOf(String s)`** — возвращает объект-оболочку:
  ```java
  Integer num = Integer.valueOf("123");
  ```

- **`xxxValue()`** — возвращает примитивное значение:
  ```java
  Integer num = 100;
  int primitive = num.intValue();
  ```

#### Примеры автопреобразований

**Автоупаковка:**
```java
int primitiveInt = 10;
Integer wrappedInt = primitiveInt; // Автоупаковка (Integer.valueOf(primitiveInt))
```

**Автораспаковка:**
```java
Integer wrappedInt = 20;
int primitiveInt = wrappedInt; // Автораспаковка (wrappedInt.intValue())
```

#### Применение в коллекциях
Коллекции в Java не поддерживают примитивные типы. Автоупаковка позволяет использовать примитивы в коллекциях без явного преобразования:

```java
List<Integer> numbers = new ArrayList<>();
numbers.add(5);  // Автоупаковка int -> Integer
int num = numbers.get(0);  // Автораспаковка Integer -> int
```

#### Потенциальные проблемы

- **Производительность:** Автоупаковка/автораспаковка создаёт дополнительные объекты, что может увеличить нагрузку на сборщик мусора.
- **NullPointerException:** попытка автораспаковки `null` приведёт к ошибке:

```java
Integer num = null;
int value = num; // NullPointerException
```

- **Неочевидные ошибки сравнения:**

```java
Integer a = 127;
Integer b = 127;
System.out.println(a == b); // true (используется кеш)

Integer c = 128;
Integer d = 128;
System.out.println(c == d); // false (разные объекты)
```

#### Рекомендации

1. **Оптимизировать работу с памятью:** избегать ненужной автоупаковки в критичных по производительности местах.
2. **Проверять объекты на `null`:** перед автораспаковкой убедиться, что объект не равен `null`.
3. **Использовать примитивные типы:** применять примитивные типы там, где не требуется объектная оболочка.
4. **Осторожно использовать операторы сравнения:** для сравнения объектов использовать `.equals()` вместо `==`.

Автоупаковка и автораспаковка упрощают работу с коллекциями и API, требующими объектов, но требуют внимательности в высоконагруженных приложениях.

### Поведение в памяти (Stack/Heap)

#### Стек (Stack)

- **Расположение:** каждый поток в Java получает свой собственный стек.
- **Скорость:** доступ к данным в стеке происходит быстрее, чем в куче.
- **Жизненный цикл:** переменные в стеке существуют до завершения метода, в котором они были созданы.
- **Хранение:**
   - Локальные переменные и аргументы методов.
   - Ссылки на объекты в куче (а не сами объекты).

**Пример:**
```java
public void exampleMethod() {
    int a = 10;               // хранится в стеке
    String text = "Hello";   // ссылка хранится в стеке, объект в куче
}
```

#### Куча (Heap)

- **Расположение:** доступна всем потокам.
- **Использование:** хранение объектов и массивов.
- **Скорость:** медленнее стека из-за необходимости управления памятью.
- **Сборка мусора:** объекты в куче очищаются сборщиком мусора (Garbage Collector), когда на них нет ссылок.

**Пример:**
```java
String message = new String("Hello, World!"); // объект хранится в куче
```

#### Сравнение стека и кучи

| Характеристика         | Стек (Stack)                        | Куча (Heap)                     |
|-----------------------|-------------------------------------|--------------------------------|
| Скорость доступа      | Быстрая                             | Медленная                      |
| Управление памятью    | Автоматическое (LIFO)               | Сборщик мусора (GC)           |
| Область видимости     | Локальная для потока                | Доступна всем потокам         |
| Жизненный цикл данных | Ограничен временем выполнения метода| До удаления сборщиком мусора  |

#### Рекомендации по работе с памятью

1. **Используйте примитивы, где это возможно:** они хранятся в стеке и не создают дополнительной нагрузки на память.
2. **Ограничивайте создание объектов:** избегайте ненужных объектов в часто вызываемых методах.
3. **Контролируйте утечки памяти:** следите за тем, чтобы не сохранять лишние ссылки на объекты, которые больше не нужны.
4. **Используйте слабые ссылки (`WeakReference`):** для объектов, которые можно освободить при нехватке памяти.

Понимание поведения в памяти позволяет писать более эффективный и оптимизированный код.

### Передача по значению и по ссылке

В Java все аргументы передаются **по значению**. Однако важно понимать, как это работает для примитивных типов и объектов.

#### 📌 Передача примитивных типов данных

Примитивные типы данных (int, double, boolean и др.) передаются по значению. Это означает, что при передаче переменной в метод создаётся её копия, и любые изменения этой копии не влияют на оригинал.

**Пример:**
```java
public class PrimitiveExample {
    public static void main(String[] args) {
        int a = 5;
        modifyValue(a);
        System.out.println(a);  // Output: 5
    }

    static void modifyValue(int num) {
        num = 10;
    }
}
```
**Объяснение:** Метод `modifyValue` работает с копией переменной `a`, поэтому значение `a` остаётся неизменным.

#### 📌 Передача объектов

Объекты в Java также передаются **по значению**, но это значение — **ссылка на объект**. Это значит, что копируется ссылка на объект, а не сам объект. Изменяя поля объекта, мы фактически меняем сам объект, на который ссылается переменная.

**Пример:**
```java
public class ObjectExample {
    public static void main(String[] args) {
        Person person = new Person("Alice");
        modifyPerson(person);
        System.out.println(person.getName());  // Output: Bob
    }

    static void modifyPerson(Person p) {
        p.setName("Bob");
    }
}

class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```
**Объяснение:** В метод `modifyPerson` передаётся копия ссылки на объект `person`. Изменяя поле `name`, мы меняем сам объект.

#### ⚠️ Ошибочное понимание передачи по ссылке

Многие считают, что объекты в Java передаются по ссылке. Это неверно. Если попытаться переназначить объект внутри метода, оригинальный объект не изменится.

**Пример:**
```java
public class ReferenceExample {
    public static void main(String[] args) {
        Person person = new Person("Alice");
        reassignPerson(person);
        System.out.println(person.getName());  // Output: Alice
    }

    static void reassignPerson(Person p) {
        p = new Person("Bob");
    }
}
```
**Объяснение:** В методе `reassignPerson` переменная `p` получает новую ссылку на объект `Person("Bob")`, но это не влияет на оригинальный объект `person` в методе `main`.

#### ✅ Выводы

- Примитивные типы передаются по значению, копируется само значение.
- Объекты передаются по значению, но копируется **ссылка на объект**.
- Переназначение объекта внутри метода не влияет на оригинальный объект.
- Изменение полей объекта через ссылку влияет на сам объект.

## String и пул строк

### Особенности String

- **Неизменяемость (Immutable):** Объекты класса `String` после создания не могут быть изменены. Любая операция над строкой, например, конкатенация или замена символов, создает новый объект в памяти. Это гарантирует безопасность при многопоточном доступе и позволяет использовать строки в качестве ключей в коллекциях, таких как `HashMap`.

  **Пример:**
  ```java
  String str1 = "Hello";
  str1 = str1 + " World";
  System.out.println(str1); // "Hello World"
  ```
  Здесь создается новый объект строки, а не изменяется исходный `"Hello"`.

- **Класс `String` является финальным:** Это значит, что класс нельзя наследовать. Такой подход защищает строку от непредсказуемого поведения при изменении логики.

- **Хранение символов:**
   - В Java 8 и ниже строка хранила символы в массиве `char[]`.
   - Начиная с Java 9, строки хранятся в массиве `byte[]` с флагом кодировки (LATIN1 или UTF16), что оптимизирует использование памяти.

- **Сравнение строк:** Оператор `==` сравнивает ссылки на объекты, а метод `equals()` — содержимое строк.

  **Пример:**
  ```java
  String a = "Java";
  String b = new String("Java");

  System.out.println(a == b);      // false (разные объекты)
  System.out.println(a.equals(b)); // true (одинаковое содержимое)
  ```

### Пул строк и его работа

- **Пул строк (String Pool):** Это специальная область в heap-памяти, где хранятся уникальные строковые литералы для оптимизации памяти.

- **Интернирование строк:** JVM проверяет наличие строки в пуле. Если строка уже существует, возвращается ссылка на нее. Если нет — создается новая строка и помещается в пул.

  **Пример:**
  ```java
  String s1 = "Hello";
  String s2 = "Hello";
  String s3 = new String("Hello");

  System.out.println(s1 == s2); // true (один объект в пуле)
  System.out.println(s1 == s3); // false (s3 — новый объект вне пула)
  ```

- **Метод `intern()`:** Принудительно добавляет строку в пул.

  **Пример:**
  ```java
  String s4 = new String("World").intern();
  String s5 = "World";
  System.out.println(s4 == s5); // true
  ```

### Строковые операции

- **Конкатенация:**
   - С помощью оператора `+` или метода `concat()`.
   - В циклах лучше использовать `StringBuilder` или `StringBuffer`.

  **Пример:**
  ```java
  String result = "Hello" + " " + "World";  // Неэффективно в цикле
  StringBuilder sb = new StringBuilder();
  sb.append("Hello").append(" ").append("World");  // Эффективно
  ```

- **Методы обработки строк:**
   - `length()`: Длина строки.
   - `charAt(int index)`: Символ по индексу.
   - `substring(int beginIndex, int endIndex)`: Подстрока.
   - `toLowerCase()` / `toUpperCase()`: Изменение регистра.
   - `trim()`: Удаление пробелов в начале и в конце.
   - `replace(CharSequence target, CharSequence replacement)`: Замена символов или подстрок.

- **Разделение строк:**

  **Пример:**
  ```java
  String data = "apple,banana,orange";
  String[] fruits = data.split(",");
  for(String fruit : fruits) {
      System.out.println(fruit);
  }
  ```

- **Поиск в строках:**
   - `indexOf(String str)`: Индекс первого вхождения.
   - `contains(CharSequence s)`: Проверка наличия подстроки.

- **Сравнение строк:**
   - `equals(String anotherString)`: Сравнение с учетом регистра.
   - `equalsIgnoreCase(String anotherString)`: Без учета регистра.
   - `compareTo(String anotherString)`: Лексикографическое сравнение.

- **Форматирование строк:**

  **Пример:**
  ```java
  String formatted = String.format("Name: %s, Age: %d", "Alice", 30);
  System.out.println(formatted); // Name: Alice, Age: 30
  ```

### Отличия String, StringBuilder, StringBuffer

В Java для работы со строками используются три основных класса: `String`, `StringBuilder` и `StringBuffer`. Каждый из них имеет свои особенности, подходящие для различных сценариев использования.

#### 1. String

- **Неизменяемость (Immutable):** После создания объекта `String` его значение нельзя изменить. Любые операции над строкой создают новый объект.
- **Пул строк (String Pool):** Строковые литералы хранятся в пуле строк, что позволяет экономить память за счёт переиспользования одинаковых строк.
- **Потокобезопасность:** Поскольку строки неизменяемы, они являются потокобезопасными.

**Пример:**
```java
String str1 = "Hello";
String str2 = str1.concat(" World");
System.out.println(str1);  // Выведет: Hello
System.out.println(str2);  // Выведет: Hello World
```

#### 2. StringBuilder

- **Изменяемость (Mutable):** Объект `StringBuilder` можно изменять без создания новых объектов.
- **Быстродействие:** Работает быстрее, чем `String` при множественных операциях над строками.
- **Не потокобезопасен:** Не синхронизирован, поэтому не рекомендуется для многопоточной среды.

**Пример:**
```java
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");
System.out.println(sb);  // Выведет: Hello World
```

#### 3. StringBuffer

- **Изменяемость (Mutable):** Как и `StringBuilder`, объекты `StringBuffer` можно изменять.
- **Потокобезопасность:** Методы синхронизированы, что делает его безопасным для многопоточной среды.
- **Меньшая производительность:** Из-за синхронизации работает медленнее, чем `StringBuilder`.

**Пример:**
```java
StringBuffer sbf = new StringBuffer("Hello");
sbf.append(" World");
System.out.println(sbf);  // Выведет: Hello World
```

#### Сравнительная таблица

| Характеристика    | String            | StringBuilder       | StringBuffer        |
|-------------------|-------------------|--------------------|--------------------|
| Изменяемость      | Нет (Immutable)   | Да (Mutable)       | Да (Mutable)       |
| Потокобезопасность| Да                | Нет                | Да                 |
| Быстродействие    | Низкое            | Высокое            | Среднее           |
| Использование     | Небольшие строки, часто используемые данные | Частые изменения строк в однопоточной среде | Частые изменения строк в многопоточной среде |

#### Рекомендации по использованию
- Используйте **String**, если строка не будет изменяться.
- Выбирайте **StringBuilder** для интенсивных операций с изменениями строки в однопоточной среде.
- Используйте **StringBuffer** в многопоточной среде для безопасных изменений строк.

## Массивы

### Объявление и инициализация

Массивы в Java представляют собой структуры данных фиксированной длины, которые хранят элементы одного типа. Объявление и инициализация массива может выполняться несколькими способами:

```java
// Объявление массива без инициализации
int[] numbers;

// Инициализация массива фиксированного размера
numbers = new int[5];

// Объявление и инициализация массива
int[] values = {1, 2, 3, 4, 5};

// Альтернативный способ объявления
int values2[] = new int[]{1, 2, 3, 4, 5};
```

**Ссылки на массивы:**
Массивы в Java являются объектами, и переменная массива хранит ссылку на объект в куче (heap), а не сами элементы:

```java
int[] array1 = {1, 2, 3};
int[] array2 = array1; // array2 указывает на тот же массив, что и array1
array2[0] = 99;
System.out.println(array1[0]); // Выведет 99
```

### Многомерные массивы

Java поддерживает многомерные массивы, которые по сути являются массивами массивов.

```java
// Двумерный массив 3x3
int[][] matrix = new int[3][3];

// Инициализация двумерного массива
int[][] matrixInit = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// Разреженный массив (разные размеры вложенных массивов)
int[][] jaggedArray = new int[3][];
jaggedArray[0] = new int[2];
jaggedArray[1] = new int[4];
jaggedArray[2] = new int[3];
```

### Операции над массивами

Массивы позволяют выполнять различные операции:

- **Доступ к элементу по индексу:**
  ```java
  int firstElement = values[0];
  ```
- **Изменение элемента:**
  ```java
  values[2] = 10;
  ```
- **Перебор элементов:**
  ```java
  // С помощью цикла for
  for (int i = 0; i < values.length; i++) {
      System.out.println(values[i]);
  }
  
  // С помощью цикла for-each
  for (int value : values) {
      System.out.println(value);
  }
  ```
- **Копирование массива:**
  ```java
  int[] copy = Arrays.copyOf(values, values.length);
  ```
- **Сортировка массива:**
  ```java
  Arrays.sort(values);
  ```
- **Поиск элемента:**
  ```java
  int index = Arrays.binarySearch(values, 10);
  ```

### Особенности работы с массивами

- **Фиксированный размер:** После инициализации размер массива изменить нельзя. Для динамических коллекций лучше использовать `ArrayList`.
- **Индексация с нуля:** Доступ к элементам осуществляется по индексу, начинающемуся с нуля.
- **Типизированность:** Все элементы массива должны быть одного типа.
- **Null по умолчанию:** Для массивов объектов элементы по умолчанию инициализируются значением `null`. Для примитивных типов — нулями или `false` для `boolean`.

  ```java
  String[] words = new String[3];
  System.out.println(words[0]); // null

  int[] numbers = new int[3];
  System.out.println(numbers[0]); // 0
  ```
- **Ошибки при выходе за границы:** Попытка обращения к элементу за пределами массива вызывает `ArrayIndexOutOfBoundsException`.

  ```java
  int[] nums = {1, 2, 3};
  System.out.println(nums[3]); // Ошибка
  ```

- **Arrays и утилитные методы:** Класс `java.util.Arrays` предоставляет множество методов для работы с массивами: сортировка, поиск, заполнение и сравнение.

  ```java
  Arrays.fill(numbers, 7); // Заполняет массив числом 7
  Arrays.equals(numbers, copy); // Сравнение массивов
  ```

- **Ссылочная природа:** При передаче массива в метод передается ссылка на массив, а не его копия:

  ```java
  public static void modifyArray(int[] arr) {
      arr[0] = 100;
  }

  int[] nums = {1, 2, 3};
  modifyArray(nums);
  System.out.println(nums[0]); // Выведет 100
  ```

---

## Обобщённые типы (Generics)

### Что такое Generics
Generics в Java позволяют создавать классы, интерфейсы и методы с параметрами типа. Это обеспечивает типобезопасность и повторное использование кода без необходимости приведения типов. Generics помогают избежать ошибок времени выполнения, связанных с некорректными преобразованиями типов.

**Преимущества Generics:**
- **Типобезопасность:** исключает ошибки, связанные с некорректными преобразованиями типов.
- **Повторное использование кода:** один универсальный класс или метод работает с разными типами данных.
- **Улучшение читаемости кода:** избавляет от необходимости приведения типов.

**Пример:**
```java
// Класс без Generics
List numbers = new ArrayList();
numbers.add(1);
numbers.add("строка"); // Ошибка появится только во время выполнения

// Класс с Generics
List<Integer> numbers = new ArrayList<>();
numbers.add(1);
// numbers.add("строка"); // Ошибка компиляции
```

### Ограничения типов (extends, super)
Ограничения типов позволяют задавать верхние и нижние границы для параметров типа, что делает Generics гибкими и безопасными.

**Ограничения с `extends`:** задают верхнюю границу типа. Используются, когда нужно работать с классом или интерфейсом и его подклассами.

**Пример:**
```java
public class Box<T extends Number> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }
}

Box<Integer> intBox = new Box<>(); // Разрешено
Box<Double> doubleBox = new Box<>(); // Разрешено
// Box<String> strBox = new Box<>();  // Ошибка компиляции
```

**Ограничения с `super`:** задают нижнюю границу типа. Используются, когда нужно добавлять элементы в коллекцию. Это позволяет безопасно записывать объекты указанного типа или его подклассов, но ограничивает чтение до типа `Object`.

**Объяснение:**
- С `? super T` можно добавлять объекты типа `T` и его подклассов.
- Чтение ограничено типом `Object`, так как точный тип элементов неизвестен.

**Различие между `extends` и `super`:**
- `? extends T` позволяет только **считывать** элементы, но **не добавлять** новые, так как неизвестно, какой именно тип содержится в коллекции.
- `? super T` позволяет **добавлять** элементы типа `T` или его подклассов, но **считывать** можно только как `Object`.

**Пример:**
```java
public void addNumbers(List<? super Integer> list) {
    list.add(1);  // Разрешено
    list.add(2);
    // Integer num = list.get(0); // Ошибка компиляции
    Object obj = list.get(0);    // Разрешено
}

List<Number> numbers = new ArrayList<>();
addNumbers(numbers);
```

**Антипример:**
```java
public void addNumbers(List<? super Number> list) {
    // list.add("строка"); // Ошибка компиляции: нельзя добавить строку в список чисел
    list.add(10); // Разрешено
}
```

**Наглядное объяснение:**
- `List<? super Integer>` может быть `List<Integer>`, `List<Number>` или `List<Object>`.
- Это удобно для **записи** данных, но ограничено для **чтения**.

### Wildcards

В Java **Wildcards** (подстановочные знаки) используются для создания гибких и безопасных дженериков. Они позволяют работать с обобщёнными типами, не указывая конкретный тип, а задавая его границы. Основной символ wildcard — это вопросительный знак (`?`).

Wildcards бывают трёх видов:

---

#### 1. **Неограниченный Wildcard (`?`)**

Используется, когда тип неизвестен и неважен.

**Пример:**
```java
public void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}
```
**Объяснение:** Метод принимает список с элементами любого типа. Мы не можем добавлять в него элементы, но можем безопасно читать.

---

#### 2. **Ограниченный сверху Wildcard (`? extends T`)**

Используется, когда нужно работать с объектами типа `T` или его подклассами.

**Пример:**
```java
public void printNumbers(List<? extends Number> list) {
    for (Number number : list) {
        System.out.println(number);
    }
}
```
**Объяснение:** Метод принимает списки чисел (`Integer`, `Double`, `Float` и т.д.), но мы не можем добавлять элементы, чтобы сохранить типовую безопасность.

**Ключевая особенность:**
- Можно **читать**, но нельзя **записывать** элементы в коллекцию.

---

#### 3. **Ограниченный снизу Wildcard (`? super T`)**

Используется, когда нужно работать с объектами типа `T` или его супертипами.

**Пример:**
```java
public void addIntegers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
    // list.add(3.14); // Ошибка компиляции
}
```
**Объяснение:** Метод принимает списки `Integer` или более общих типов (`Number`, `Object`). В коллекцию можно добавлять объекты типа `Integer` или его подклассов.

**Ключевая особенность:**
- Можно **записывать**, но безопасно **читать** можно только как `Object`.

---

### 🔎 **Различия между `extends` и `super`**

| Характеристика          | `? extends T`                          | `? super T`                           |
|------------------------|----------------------------------------|-------------------------------------|
| Направление ограничения | Верхняя граница (подклассы)            | Нижняя граница (суперклассы)        |
| Чтение элементов        | ✅ Можно читать                        | ✅ Можно читать как `Object`         |
| Запись элементов        | ❌ Нельзя добавлять                    | ✅ Можно добавлять объекты типа `T`  |
| Пример использования    | `List<? extends Number>`               | `List<? super Integer>`             |

---

### 📝 **Рекомендации по использованию Wildcards**

- Используйте `? extends T`, когда коллекция только **читается**.
- Используйте `? super T`, когда коллекция только **заполняется**.
- Используйте неограниченный wildcard `?`, когда тип не важен (например, для операций вывода).

**Правило PECS:**
- **P**roducer — `extends` (если коллекция **производит** данные — читаем).
- **C**onsumer — `super` (если коллекция **потребляет** данные — записываем).

---

### ❗ **Ошибки и ограничения Wildcards**

1. **Нельзя создавать экземпляры с wildcard:**
   ```java
   List<?> list = new ArrayList<?>(); // Ошибка
   ```
   Wildcards применимы только к переменным и методам, но не к инициализации.

2. **Нельзя добавлять элементы в коллекции с `? extends T`:**
   ```java
   List<? extends Number> numbers = new ArrayList<Integer>();
   numbers.add(10); // Ошибка
   ```
   Добавление недопустимо из-за неизвестного точного типа.

3. **Можно добавлять `null`:**
   ```java
   List<? extends Number> numbers = new ArrayList<>();
   numbers.add(null); // Допустимо
   ```
   В коллекции с wildcard можно добавлять только `null`.

---

### ✅ **Заключение**

Wildcards делают дженерики гибкими и безопасными. Они помогают контролировать типы в коллекциях и других обобщённых структурах, сохраняя баланс между безопасностью типов и удобством использования.

- `? extends T` — читаем, но не записываем.
- `? super T` — записываем, но читаем как `Object`.
- `?` — когда тип не важен.

Правильное использование wildcards помогает избежать ошибок типов и делает код чище и надёжнее.

---
## Тип var (с Java 10):

### Локальная инференция типов

Ключевое слово `var`, введённое в Java 10, позволяет компилятору автоматически выводить тип переменной на основе присваиваемого значения. Это упрощает код, делая его более читаемым и менее перегруженным типами.

**Примеры:**

```java
var number = 10;              // int
var text = "Hello, World!";   // String
var list = new ArrayList<String>(); // ArrayList<String>
```

Здесь типы `int`, `String` и `ArrayList<String>` выводятся автоматически. Однако переменные, объявленные с `var`, должны быть инициализированы сразу.

**Недопустимо:**
```java
var value; // Ошибка компиляции: невозможно вывести тип без инициализации
value = 5;
```

### Когда использовать и ограничения

**Когда использовать:**
- Когда тип очевиден из контекста:
  ```java
  var stream = list.stream(); // Тип Stream<T>
  ```
- Для упрощения длинных объявлений:
  ```java
  var map = new HashMap<String, List<Integer>>();
  ```
- При работе с анонимными или сложными типами:
  ```java
  var entry = Map.of("key", 42).entrySet().iterator().next();
  ```

**Ограничения:**
- `var` можно использовать только для локальных переменных (в методах, блоках инициализации и циклах).
- Нельзя использовать для полей класса или параметров методов.
- Не допускается инициализация `null` без явного указания типа:
  ```java
  var data = null; // Ошибка компиляции
  var data = (String) null; // Корректно
  ```
- Не рекомендуется использовать, если тип неочевиден и ухудшает читаемость:
  ```java
  var result = process(); // Что возвращает process()? Неочевидно
  ```

**Вывод:**
`var` — удобный инструмент для упрощения кода, но его следует применять с осторожностью, чтобы сохранить читаемость и ясность кода.
---

## Работа сборщика мусора (GC) с объектами

Сборщик мусора (Garbage Collector, GC) в Java автоматически управляет памятью, освобождая неиспользуемые объекты и предотвращая утечки памяти. GC работает с памятью кучи (Heap), где хранятся все объекты и массивы.

### 🔄 Основные концепции работы GC

1. **Автоматическое управление памятью**  
   JVM автоматически отслеживает объекты, которые больше не используются, и удаляет их.

2. **Сбор мусора недостижимых объектов**  
   Объект считается недостижимым, если на него больше нет ссылок. Такие объекты подлежат удалению.

3. **Поддержка нескольких алгоритмов GC**  
   JVM предоставляет несколько алгоритмов для сборки мусора, которые можно выбрать в зависимости от задачи.

### 🏗️ Структура памяти кучи (Heap)

1. **Young Generation (Молодое поколение)**
    - **Eden Space**: Новые объекты создаются здесь.
    - **Survivor Spaces (S0 и S1)**: Объекты, пережившие одну или несколько сборок, перемещаются сюда.

2. **Old Generation (Старое поколение)**  
   Объекты, которые живут долго, перемещаются сюда. GC выполняется реже, но занимает больше времени.

3. **Metaspace**  
   Хранит метаинформацию о классах. С Java 8 заменила PermGen.

### ⚙️ Алгоритмы сборки мусора

1. **Serial GC**
    - Используется для однопоточных приложений.
    - Проводит сборку мусора последовательно.

2. **Parallel GC (Throughput Collector)**
    - Работает многопоточно, оптимизирован для максимальной пропускной способности.

3. **G1 GC (Garbage First)**
    - Делит кучу на регионы.
    - Минимизирует паузы благодаря инкрементальному сбору.

4. **ZGC (Java 11+)**
    - Низкие паузы (миллисекунды).
    - Поддерживает большие объемы памяти.

5. **Shenandoah GC (Java 12+)**
    - Минимальные паузы за счет параллельной работы с приложением.

### 🔍 Этапы работы GC

1. **Маркировка (Mark)**  
   Определяет все доступные (живые) объекты.

2. **Удаление (Sweep)**  
   Очищает недостижимые объекты.

3. **Компактирование (Compact)**  
   Перемещает объекты для устранения фрагментации памяти.

### 🚀 Настройка GC в JVM

1. **Выбор GC** через флаги JVM:
    - `-XX:+UseSerialGC` — Serial GC.
    - `-XX:+UseParallelGC` — Parallel GC.
    - `-XX:+UseG1GC` — G1 GC (по умолчанию с Java 9).
    - `-XX:+UseZGC` — ZGC.

2. **Настройки памяти:**
    - `-Xms<size>` — начальный размер кучи.
    - `-Xmx<size>` — максимальный размер кучи.

### 📊 Пример работы GC

```java
public class GCDemo {
    public static void main(String[] args) {
        for (int i = 0; i < 1000000; i++) {
            String data = new String("Test " + i);
        }
        System.gc(); // Явный вызов GC (не гарантирует немедленного запуска)
    }
}
```

⚠️ **Важно:** Вызов `System.gc()` — это только рекомендация для JVM, и она может проигнорировать этот вызов.

### 📝 Рекомендации для оптимизации GC

1. **Избегайте создания лишних объектов.**
2. **Используйте пулы объектов и коллекции с учетом нагрузки.**
3. **Оптимизируйте размер кучи и выбирайте подходящий GC.**
4. **Профилируйте приложение с помощью инструментов (JVisualVM, JFR).**

GC играет ключевую роль в управлении памятью и производительностью Java-приложений. Понимание его работы позволяет избегать утечек памяти и оптимизировать ресурсы.
