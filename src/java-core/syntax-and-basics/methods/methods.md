#### [Объявление и структура методов](#Объявление-и-структура-методов-1)
#### [Вызов методов](#Вызов-методов-1)
#### [Перегрузка методов (method overloading)](#Перегрузка-методов-method-overloading-1)
#### [Переопределение методов (method overriding)](#Переопределение-методов-method-overriding-1)
#### [Рекурсия](#Рекурсия-1)
#### [Вариативные аргументы (varargs)](#Вариативные-аргументы-varargs-1)
#### [Методы с параметрами](#Методы-с-параметрами-1)
#### [Статические методы](#Статические-методы-1)
#### [Абстрактные методы](#Абстрактные-методы-1)
#### [Методы по умолчанию в интерфейсах](#Методы-по-умолчанию-в-интерфейсах-1)
#### [Ссылки на методы (method references)](#Ссылки-на-методы-method-references-1)
#### [Оптимальные практики работы с методами](#Оптимальные-практики-работы-с-методами-1)

--- 

# Методы

## Объявление и структура методов

Методы в Java являются основными строительными блоками для выполнения логики. Каждый метод имеет чёткую структуру, включающую несколько ключевых элементов.

### Основные элементы

1. **Сигнатура метода**
    - Определяет уникальность метода и включает:
        - Имя метода.
        - Список параметров (с указанием их типов).
2. **Модификаторы доступа**
    - Определяют уровень доступа метода.
        - `public`: Доступен везде.
        - `private`: Доступен только внутри класса.
        - `protected`: Доступен в пакете и у наследников.
        - `default` (без указания модификатора): Доступен только в пакете.
3. **Тип возвращаемого значения**
    - Указывает тип данных, которые метод возвращает. Если метод ничего не возвращает, используется ключевое слово `void`.
4. **Имя метода**
    - Должно быть осмысленным и соответствовать соглашениям об именах (camelCase).
5. **Список параметров**
    - Указывается в круглых скобках после имени метода. Параметры разделяются запятыми и включают тип данных и имя.
6. **Тело метода**
    - Заключено в фигурные скобки `{}` и содержит инструкции, которые выполняются при вызове метода.

### Порядок компонентов метода

Методы имеют строгий порядок компонентов. Пример:

```java
public int addNumbers(int a, int b) {
    return a + b;
}
```

1. **Модификатор доступа**: `public`.
2. **Тип возвращаемого значения**: `int`.
3. **Имя метода**: `addNumbers`.
4. **Список параметров**: `(int a, int b)`.
5. **Тело метода**: `{ return a + b; }`.

### Пример с комментариями

```java
// Модификатор доступа
public 
// Тип возвращаемого значения
String 
// Имя метода
getGreeting 
// Список параметров
(String name) {
    // Тело метода
    return "Привет, " + name + "!";
}
```

## Вызов методов

### Прямой вызов
Прямой вызов метода осуществляется на экземпляре класса. Это стандартный способ вызова методов, которые не являются статическими. Метод вызывается с использованием оператора `.` (точка) после имени объекта.

**Пример:**
```java
class Calculator {
    int add(int a, int b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        int result = calculator.add(5, 10); // Прямой вызов метода add
        System.out.println("Результат: " + result);
    }
}
```
> Важно: При прямом вызове метода можно получить доступ к нестатическим полям и методам объекта.

### Вызов статических методов
Статические методы принадлежат самому классу и вызываются без создания экземпляра. Для вызова статического метода используется имя класса, за которым следует оператор `.` и имя метода.

**Пример:**
```java
class MathUtils {
    static int multiply(int a, int b) {
        return a * b;
    }
}

public class Main {
    public static void main(String[] args) {
        int product = MathUtils.multiply(5, 4); // Вызов статического метода multiply
        System.out.println("Произведение: " + product);
    }
}
```
> Замечание: Статические методы не могут обращаться к нестатическим полям или методам без ссылки на экземпляр класса.

**Ключевые различия между прямым вызовом и вызовом статических методов:**

| Характеристика                  | Прямой вызов                               | Вызов статического метода               |
|---------------------------------|--------------------------------------------|-----------------------------------------|
| Требуется ли объект             | Да                                         | Нет                                      |
| Доступ к нестатическим полям    | Есть                                       | Нет                                      |
| Доступ к статическим полям      | Есть                                       | Есть                                     |
| Производительность              | Немного ниже из-за необходимости создавать объект | Выше, так как вызов осуществляется напрямую через класс |

## Перегрузка методов (Method Overloading)

### Что такое перегрузка методов
Перегрузка методов (Method Overloading) — это механизм в Java, который позволяет создавать несколько методов с одним и тем же именем, но с разными параметрами (типами или количеством). Это улучшает читаемость и структурированность кода, позволяя использовать одно имя метода для различных сценариев.

Основные принципы перегрузки:
- Методы должны иметь одно и то же имя.
- Параметры должны различаться по типу, количеству или порядку.
- Возвращаемый тип не влияет на определение перегрузки.

Пример:
```
class Calculator {
    // Метод для сложения двух чисел
    int add(int a, int b) {
        return a + b;
    }

    // Метод для сложения трёх чисел
    int add(int a, int b, int c) {
        return a + b + c;
    }

    // Метод для сложения чисел с плавающей точкой
    double add(double a, double b) {
        return a + b;
    }
}
```

### Примеры использования перегрузки
1. **Работа с разными типами данных:**
   ```
   class Printer {
       void print(int number) {
           System.out.println("Integer: " + number);
       }

       void print(String text) {
           System.out.println("String: " + text);
       }

       void print(double number) {
           System.out.println("Double: " + number);
       }
   }

   public class Main {
       public static void main(String[] args) {
           Printer printer = new Printer();
           printer.print(10);       // Вызов метода с int
           printer.print("Hello");  // Вызов метода с String
           printer.print(5.5);      // Вызов метода с double
       }
   }
   ```

2. **Улучшение читаемости:**

   Вместо создания методов с разными именами (например, `addInt`, `addDouble`), можно использовать перегрузку:
   ```
   Calculator calc = new Calculator();
   System.out.println(calc.add(5, 10));         // Output: 15
   System.out.println(calc.add(2.5, 3.1));     // Output: 5.6
   System.out.println(calc.add(1, 2, 3));      // Output: 6
   ```

### Ограничения и особенности
1. **Перегрузка на основе возвращаемого типа невозможна:**
   ```
   int exampleMethod(int a) { return a; }
   double exampleMethod(int a) { return a; } // Ошибка компиляции
   ```

2. **Параметры должны различаться:**
   ```
   void method(int a, String b) {}
   void method(String b, int a) {} // Это допустимо, так как порядок параметров разный
   ```

3. **Автоматическое приведение типов:**
   При наличии подходящего метода Java может выполнять приведение типов:
   ```
   void method(double a) {
       System.out.println("Double: " + a);
   }

   void method(int a) {
       System.out.println("Integer: " + a);
   }

   public static void main(String[] args) {
       method(5);    // Вызовет метод с int
       method(5.5);  // Вызовет метод с double
   }
   ```

4. **Не путать с переопределением (Overriding):**
   Перегрузка выполняется в пределах одного класса и связана с разными параметрами, тогда как переопределение изменяет реализацию метода в подклассе.

> **Замечание:** Перегрузка методов делает код более гибким и удобным для использования, особенно при работе с универсальными функциями, такими как форматирование или вычисления.

## Переопределение методов (Method Overriding)

### Что такое переопределение
Переопределение метода (Method Overriding) — это механизм в объектно-ориентированном программировании, который позволяет подклассу предоставлять свою собственную реализацию метода, уже определённого в его суперклассе. Это важно для реализации полиморфизма и обеспечения гибкости кода.

**Ключевые моменты:**
- Метод в подклассе должен иметь ту же сигнатуру (имя, параметры и тип возвращаемого значения), что и в суперклассе.
- Переопределённый метод вызывается по ссылке на объект подкласса, даже если переменная имеет тип суперкласса.

**Пример:**
```java
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.sound();  // Output: Dog barks
    }
}
```

### Использование аннотации @Override
Аннотация `@Override` указывает, что метод переопределяет метод суперкласса. Это помогает избежать ошибок, связанных с опечатками или неправильной сигнатурой метода.

**Преимущества использования @Override:**
- Проверка компилятором правильности переопределения.
- Повышает читаемость кода.

**Пример:**
```java
class Bird {
    void fly() {
        System.out.println("Bird is flying");
    }
}

class Sparrow extends Bird {
    @Override
    void fly() {
        System.out.println("Sparrow is flying low");
    }
}
```

**Ошибочный пример без @Override:**
```java
class Sparrow extends Bird {
    // Ошибка: компилятор не обнаружит опечатку без @Override
    void Fly() {  // Неверно: должно быть fly()
        System.out.println("Sparrow is flying low");
    }
}
```

### Отличия переопределения от перегрузки
**Переопределение (Overriding):**
- Определяется в подклассе.
- Имеет ту же сигнатуру, что и в суперклассе.
- Позволяет реализовать полиморфизм.

**Перегрузка (Overloading):**
- Происходит в одном и том же классе.
- Методы имеют одинаковое имя, но разные параметры.
- Не связана с полиморфизмом.

**Пример перегрузки:**
```java
class Calculator {
    int add(int a, int b) {
        return a + b;
    }
    
    double add(double a, double b) {
        return a + b;
    }
}
```

### Полиморфизм через переопределение
Переопределение является основой для реализации полиморфизма. Оно позволяет использовать один интерфейс для различных типов объектов.

**Пример:**
```java
class Shape {
    void draw() {
        System.out.println("Drawing a shape");
    }
}

class Circle extends Shape {
    @Override
    void draw() {
        System.out.println("Drawing a circle");
    }
}

class Square extends Shape {
    @Override
    void draw() {
        System.out.println("Drawing a square");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape shape1 = new Circle();
        Shape shape2 = new Square();

        shape1.draw();  // Output: Drawing a circle
        shape2.draw();  // Output: Drawing a square
    }
}
```

**Пояснение:**
- Переменные `shape1` и `shape2` имеют тип `Shape`, но вызывают методы, определённые в подклассах `Circle` и `Square`.
- Это демонстрирует динамическое связывание (late binding) и полиморфизм.

## Рекурсия

### Примеры и базовые принципы рекурсии
Рекурсия — это процесс, при котором метод вызывает сам себя для решения подзадач. Основные элементы рекурсии:
- **Базовый случай** — условие, при котором рекурсия прекращается.
- **Рекурсивный вызов** — вызов самого метода для решения меньшей задачи.

**Пример:** вычисление факториала числа:
```java
public class Factorial {
    public static int factorial(int n) {
        if (n <= 1) {  // Базовый случай
            return 1;
        }
        return n * factorial(n - 1);  // Рекурсивный вызов
    }

    public static void main(String[] args) {
        System.out.println(factorial(5)); // Output: 120
    }
}
```

### Прямая и косвенная рекурсия
- **Прямая рекурсия** — метод напрямую вызывает сам себя.

  **Пример:**
  ```java
  public void directRecursion() {
      // Условие выхода
      directRecursion();
  }
  ```

- **Косвенная рекурсия** — метод вызывает другой метод, который в свою очередь вызывает первый.

  **Пример:**
  ```java
  public void methodA() {
      methodB();
  }

  public void methodB() {
      methodA();
  }
  ```

### Ограничения рекурсии (глубина стека)
Каждый рекурсивный вызов занимает место в стеке вызовов. При слишком глубокой рекурсии может произойти **StackOverflowError**.

**Пример ошибки:**
```java
public class InfiniteRecursion {
    public static void recurse() {
        recurse();
    }

    public static void main(String[] args) {
        recurse(); // Вызовет StackOverflowError
    }
}
```

**Рекомендации:**
- Использовать рекурсию только при наличии чёткого базового условия.
- Для глубокой рекурсии рассмотреть использование итерации или оптимизировать алгоритм.
- Использовать хвостовую рекурсию, где это возможно, чтобы снизить нагрузку на стек (в Java не поддерживается на уровне JVM, но может быть полезно для понимания оптимизации).

## Вариативные аргументы (varargs)

### Синтаксис ... для параметров
Вариативные аргументы (varargs) позволяют передавать переменное количество аргументов одного типа в метод. Для этого используется оператор `...`, который указывается после типа параметра.

**Синтаксис:**
```java
public void методИмя(Тип... имяПараметра) {
    // Логика метода
}
```

**Пример:**
```java
public void printNumbers(int... numbers) {
    for (int number : numbers) {
        System.out.println(number);
    }
}

// Вызовы метода
printNumbers(1);               // Output: 1
printNumbers(1, 2, 3, 4, 5);   // Output: 1 2 3 4 5
```

### Примеры использования
**Передача строк:**
```java
public void greetUsers(String... names) {
    for (String name : names) {
        System.out.println("Hello, " + name + "!");
    }
}

greetUsers("Alice", "Bob", "Charlie");
// Вывод:
// Hello, Alice!
// Hello, Bob!
// Hello, Charlie!
```

**Использование с массивами:**
```java
int[] values = {10, 20, 30};
printNumbers(values);  // Работает, так как массив совместим с varargs
```

### Ограничения при работе с varargs
1. **Только один параметр varargs:** В методе может быть только один параметр с varargs, и он должен быть последним в списке параметров.

   ❌ **Неверно:**
   ```java
   public void incorrectMethod(String... names, int... numbers) {}  // Ошибка
   ```

   ✅ **Верно:**
   ```java
   public void correctMethod(String message, int... numbers) {}
   ```

2. **Конфликты с перегрузкой методов:** Varargs может вызывать неоднозначность при перегрузке методов.

   ❌ **Неоднозначность:**
   ```java
   public void process(int... numbers) {}
   public void process(int number) {}  // Ошибка: конфликт перегрузки
   ```

3. **Производительность:** Varargs создает массив за кулисами, что может повлиять на производительность при больших объёмах данных.

4. **Null как аргумент:** Передача `null` может вызвать `NullPointerException`.

   ```java
   printNumbers(null);  // Может вызвать ошибку
   ```
   Для безопасной обработки:
   ```java
   public void printNumbers(int... numbers) {
       if (numbers == null) {
           System.out.println("No numbers provided.");
           return;
       }
       for (int number : numbers) {
           System.out.println(number);
       }
   }
   ```

## Методы с параметрами

### Передача параметров по значению
В Java все аргументы передаются в методы **по значению**. Для примитивных типов это означает передачу копии значения, а для объектов — копии ссылки на объект. Изменение ссылки внутри метода не влияет на оригинальный объект.

**Пример:**
```java
public class Example {
    public static void changeValue(int number) {
        number = 100;
    }

    public static void main(String[] args) {
        int value = 50;
        changeValue(value);
        System.out.println(value);  // Output: 50
    }
}
```
*Здесь значение `value` не изменилось, так как была передана копия.*

### Работа с объектами как параметрами
При передаче объектов в методы копируется ссылка на объект. Поэтому изменение полей объекта внутри метода отразится на оригинальном объекте.

**Пример:**
```java
public class Person {
    String name;

    public Person(String name) {
        this.name = name;
    }
}

public class Example {
    public static void changeName(Person person) {
        person.name = "Alice";
    }

    public static void main(String[] args) {
        Person person = new Person("Bob");
        changeName(person);
        System.out.println(person.name);  // Output: Alice
    }
}
```
*Поле `name` изменилось, потому что передавалась копия ссылки на объект.*

### Изменение состояния объектов через параметры
Хотя ссылку на объект изменить нельзя, можно изменить его состояние (поля или вызвать методы).

**Пример:**
```java
public class Counter {
    int count;

    public void increment() {
        count++;
    }
}

public class Example {
    public static void increaseCounter(Counter counter) {
        counter.increment();
    }

    public static void main(String[] args) {
        Counter counter = new Counter();
        increaseCounter(counter);
        System.out.println(counter.count);  // Output: 1
    }
}
```
*Метод `increment()` изменил значение поля `count`, что отразилось на объекте.*

## Статические методы

### Особенности и примеры использования
Статические методы принадлежат классу, а не его экземплярам. Они вызываются без создания объекта этого класса. Такие методы удобны для реализации служебных функций или работы с общими ресурсами.

**Пример:**
```java
public class MathUtils {
    public static int square(int number) {
        return number * number;
    }

    public static void main(String[] args) {
        int result = MathUtils.square(5);
        System.out.println(result);  // Output: 25
    }
}
```
*Метод `square` вызывается напрямую через имя класса без создания объекта.*

### Когда использовать статические методы
- Для реализации утилитарных или вспомогательных функций (например, методы в `Math`, `Collections`).
- Когда логика метода не зависит от состояния объекта.
- Для создания фабричных методов (`Factory Method`).

**Пример:**
```java
public class Logger {
    public static void log(String message) {
        System.out.println("Log: " + message);
    }

    public static void main(String[] args) {
        Logger.log("Приложение запущено");  // Output: Log: Приложение запущено
    }
}
```

### Ограничения (например, отсутствие доступа к нестатическим членам)
- Статические методы **не могут** обращаться к нестатическим (экземплярным) полям и методам напрямую.
- Внутри статического метода нельзя использовать ключевое слово `this`.

**Пример:**
```java
public class Example {
    int number = 10;

    public static void printNumber() {
        // System.out.println(number);  // Ошибка! Нельзя обращаться к нестатическим полям
    }
}
```
*Попытка обращения к нестатическому полю `number` вызовет ошибку компиляции.*

**Решение:**
Чтобы получить доступ к нестатическим членам, нужно создать объект класса:
```java
public class Example {
    int number = 10;

    public static void printNumber() {
        Example example = new Example();
        System.out.println(example.number);  // Output: 10
    }
}
```
*Создание объекта позволяет обратиться к нестатическим полям.*

## Абстрактные методы

### Определение и назначение
Абстрактные методы — это методы без реализации, которые объявляются в абстрактных классах с помощью ключевого слова `abstract`. Они задают общий контракт для подклассов, требуя обязательной реализации этого метода в конкретных (неабстрактных) классах.

**Синтаксис:**
```java
abstract class Animal {
    abstract void makeSound(); // Абстрактный метод
}
```

### Использование в абстрактных классах
Абстрактные методы могут находиться только в абстрактных классах. Такие классы не могут быть инстанцированы напрямую, но они позволяют определить базовый функционал и поведение для подклассов.

**Пример:**
```java
abstract class Animal {
    abstract void makeSound();

    void breathe() {
        System.out.println("Breathing...");
    }
}
```

### Реализация в производных классах
Классы, наследующие абстрактный класс, обязаны реализовать все его абстрактные методы. Если подкласс не реализует хотя бы один абстрактный метод, он сам должен быть объявлен как абстрактный.

**Пример:**
```java
class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat();
        
        dog.makeSound(); // Output: Bark
        cat.makeSound(); // Output: Meow
    }
}
```

**Особенности:**
- Абстрактные методы не могут иметь тело (реализацию).
- Абстрактный класс может содержать как абстрактные, так и конкретные (с реализацией) методы.
- Абстрактные методы позволяют задать обязательное поведение для всех наследников.

## Методы по умолчанию в интерфейсах

### Что такое методы по умолчанию
Методы по умолчанию (default methods) в интерфейсах были введены в Java 8. Они позволяют добавлять реализацию метода прямо в интерфейс, не нарушая совместимость с уже существующими реализациями. Это решает проблему множественного наследования поведения без необходимости изменять классы, которые уже реализуют интерфейс.

### Синтаксис с аннотацией `default`
```java
public interface Printable {
    void print();
    
    default void printWithPrefix(String prefix) {
        System.out.println(prefix + ": " + this.toString());
    }
}

public class Document implements Printable {
    @Override
    public void print() {
        System.out.println("Печать документа");
    }
}

public class Main {
    public static void main(String[] args) {
        Document doc = new Document();
        doc.print();
        doc.printWithPrefix("Документ");
    }
}
```
**Вывод:**
```
Печать документа
Документ: Document@6bc7c054
```

### Ограничения методов по умолчанию
1. **Конфликты множественного наследования:** Если класс реализует несколько интерфейсов с одинаковыми методами по умолчанию, необходимо переопределить этот метод в классе.

   ```java
   interface A {
       default void show() {
           System.out.println("A");
       }
   }
   
   interface B {
       default void show() {
           System.out.println("B");
       }
   }
   
   public class C implements A, B {
       @Override
       public void show() {
           A.super.show();  // Явное указание интерфейса
       }
   }
   ```
   **Вывод:**
   ```
   A
   ```

2. **Не могут быть `final`, `static` или `abstract`.**
   Методы по умолчанию не могут быть объявлены как `final`, `static` или `abstract`.

3. **Не поддерживают множественное состояние.**
   Методы по умолчанию не могут хранить состояние, поскольку интерфейсы не могут иметь экземплярные поля.

### Преимущества методов по умолчанию
- Позволяют эволюционировать интерфейсы без нарушения обратной совместимости.
- Уменьшают дублирование кода между реализациями интерфейсов.

### Недостатки методов по умолчанию
- Возможность конфликтов при множественном наследовании.
- Потенциальное усложнение проектирования интерфейсов.

**Итог:** Методы по умолчанию — мощный инструмент для добавления новой функциональности в интерфейсы без необходимости модификации существующих классов. Однако следует использовать их с осторожностью, чтобы избежать конфликтов и не усложнить архитектуру.

## Ссылки на методы (Method References)

### Синтаксис и примеры использования
Ссылки на методы упрощают синтаксис лямбда-выражений, ссылаясь на уже существующие методы. Синтаксис:

```java
Класс::метод
```

**Примеры:**

1. **Ссылка на статический метод:**
```java
Function<Integer, String> intToString = String::valueOf;
System.out.println(intToString.apply(10)); // "10"
```

2. **Ссылка на метод экземпляра конкретного объекта:**
```java
String text = "Hello";
Supplier<Integer> lengthSupplier = text::length;
System.out.println(lengthSupplier.get()); // 5
```

3. **Ссылка на метод экземпляра произвольного объекта определённого типа:**
```java
Function<String, Integer> stringLength = String::length;
System.out.println(stringLength.apply("Java")); // 4
```

4. **Ссылка на конструктор:**
```java
Supplier<List<String>> listSupplier = ArrayList::new;
List<String> list = listSupplier.get();
```

### Применение с лямбда-выражениями
Ссылки на методы — это краткая форма записи лямбда-выражений. Например:

**Лямбда:**
```java
list.forEach(s -> System.out.println(s));
```
**Эквивалентная ссылка на метод:**
```java
list.forEach(System.out::println);
```

### Типы ссылок
1. **Ссылка на статический метод:**
    - `Класс::статическийМетод`
    - Пример: `Math::abs`

2. **Ссылка на метод экземпляра конкретного объекта:**
    - `объект::метод`
    - Пример: `"Java"::toLowerCase`

3. **Ссылка на метод экземпляра произвольного объекта конкретного типа:**
    - `Класс::метод`
    - Пример: `String::isEmpty`

4. **Ссылка на конструктор:**
    - `Класс::new`
    - Пример: `ArrayList::new`

### Ограничения
- Сигнатура метода, на который ссылаются, должна совпадать с сигнатурой функционального интерфейса.
- Нельзя ссылаться на нестатический метод из статического контекста без объекта.
- Нельзя ссылаться на методы с переменным количеством аргументов, если они не совпадают по сигнатуре.

## Оптимальные практики работы с методами

1. **Именование методов**
    - Используйте описательные названия, отражающие цель метода.
    - Начинайте названия методов с глаголов, например: `calculateSum`, `fetchData`, `isValid`.
    - Следуйте соглашениям об именовании, принятым в вашем проекте или команде.

2. **Размер методов и принцип Single Responsibility**
    - Метод должен выполнять только одну задачу. Это упрощает тестирование и сопровождение.
    - Если метод слишком длинный или сложно читаемый, разделите его на несколько более мелких.
    - Пример:
      ```java
      public void processOrder(Order order) {
          validateOrder(order);
          calculateTotal(order);
          saveOrder(order);
      }
      ```

3. **Уменьшение числа параметров**
    - Старайтесь минимизировать количество параметров в методах (не более 3-4).
    - Если требуется больше параметров, рассмотрите использование объекта-контейнера для их объединения.
    - Пример:
      ```java
      // Вместо длинного списка параметров:
      public void createUser(String name, int age, String email, String phone) {
          // ...
      }
 
      // Используйте объект-контейнер:
      public void createUser(User user) {
          // ...
      }
      ```

4. **Документирование методов**
    - Используйте JavaDoc для описания назначения метода, его параметров и возвращаемого значения.
    - Обязательно указывайте, какие исключения может выбросить метод.
    - Пример:
      ```java
      /**
       * Вычисляет сумму двух чисел.
       *
       * @param a первое число
       * @param b второе число
       * @return сумма чисел a и b
       * @throws IllegalArgumentException если a или b равны null
       */
      public int calculateSum(Integer a, Integer b) {
          if (a == null || b == null) {
              throw new IllegalArgumentException("Параметры не могут быть null");
          }
          return a + b;
      }
      ```
