#### [Как работает хэширование](#Как-работает-хэширование-1)
#### [Динамическое перераспределение бакетов при расширении](#Динамическое-перераспределение-бакетов-при-расширении-1)
#### [Сравнение производительности коллекций](#Сравнение-производительности-коллекций-1)

---
# Бакеты в HashMap

HashMap в Java представляет собой структуру данных на основе хэш-таблицы, которая эффективно хранит пары ключ-значение. Ключи хранятся в так называемых "бакетах" (buckets), которые используются для разрешения коллизий.

## Как работает хэширование
1. **Генерация хэш-кода**: Для каждого ключа вызывается метод `hashCode()`, который возвращает целое число.
2. **Определение индекса бакета**: Индекс вычисляется с помощью операции:
   ```java
   index = (n - 1) & hash;
   ```
   где `n` — текущий размер таблицы (всегда степень двойки).
3. **Размещение в бакете**: Если несколько ключей имеют одинаковый индекс (коллизия), элементы размещаются в одной цепочке в этом бакете.

### Пример: как распределяются ключи по бакетам

#### Ключи и их хэш-коды
| Ключ        | hashCode() | Индекс бакета (при n = 8) |
|-------------|------------|--------------------------|
| "User1"     | 123456     | 0                        |
| "User2"     | 234567     | 7                        |
| "Admin"     | 123460     | 0                        |
| "Moderator" | 987654     | 2                        |

#### Визуализация бакетов
```
Bucket Index | Elements
--------------------------------
0            | [User1 -> Object1] -> [Admin -> Object2]
1            | 
2            | [Moderator -> Object3]
3            | 
4            | 
5            | 
6            | 
7            | [User2 -> Object4]
```

- Ключи "User1" и "Admin" попали в один бакет (индекс 0), образовав цепочку.
- Остальные ключи распределены по другим бакетам в зависимости от их хэш-кодов.

### Пример кода:
```java
import java.util.HashMap;

public class HashMapBucketsExample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>(8);
        map.put("User1", "Object1");
        map.put("User2", "Object4");
        map.put("Admin", "Object2");
        map.put("Moderator", "Object3");

        // Демонстрация содержания
        System.out.println("HashMap: " + map);
    }
}
```

---

## Динамическое перераспределение бакетов при расширении

Когда количество элементов превышает порог (обычно 75% от текущей емкости), `HashMap` увеличивает размер массива бакетов вдвое и перераспределяет элементы. Это необходимо для поддержания производительности.

### Алгоритм расширения:
1. **Новый размер**: Размер массива бакетов удваивается.
2. **Перехеширование**: Для каждого элемента вычисляется новый индекс бакета.
3. **Распределение**: Элементы распределяются по новым бакетам.

#### Пример перераспределения:
- Изначально `n = 4`:
```
Bucket Index | Elements
--------------------------------
0            | [User1 -> Object1]
1            | [User2 -> Object4]
2            | [Admin -> Object2]
3            | [Moderator -> Object3]
```
- После добавления нового элемента:
```
Bucket Index | Elements
--------------------------------
0            | [User1 -> Object1]
1            | [User2 -> Object4]
2            | [Admin -> Object2]
3            | [Moderator -> Object3] -> [NewUser -> Object5]
```
- При превышении порога:
```
Bucket Index | Elements (после resize)
-------------------------------------
0            | [User1 -> Object1]
1            | 
2            | [User2 -> Object4]
3            | 
4            | [Admin -> Object2]
5            | 
6            | [Moderator -> Object3]
7            | [NewUser -> Object5]
```

---

## Сравнение производительности коллекций

| Операция              | HashMap     | TreeMap          | LinkedHashMap |
|-----------------------|-------------|------------------|---------------|
| Вставка               | O(1)        | O(log n)         | O(1)          |
| Поиск по ключу        | O(1)        | O(log n)         | O(1)          |
| Удаление              | O(1)        | O(log n)         | O(1)          |
| Итерация              | Быстрая, но порядок не гарантируется | Гарантированный порядок (по ключу) | Порядок вставки |

### Рекомендации:
- Используйте `HashMap` для быстрого доступа без учета порядка.
- Выбирайте `TreeMap`, если требуется сортировка ключей.
- Предпочитайте `LinkedHashMap` для сохранения порядка вставки.
